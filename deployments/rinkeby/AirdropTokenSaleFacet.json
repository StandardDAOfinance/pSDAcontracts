{
  "address": "0xde2aEa52dC5DF3515A064a07Fee0130DD17112B3",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "airdropId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "beneficiary",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "AirdropRedeemed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "power",
          "type": "uint256"
        }
      ],
      "name": "PowerUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "purchaser",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "quantity",
          "type": "uint256"
        }
      ],
      "name": "TokenPurchased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenHash",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collectionHash",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "payee",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "openState",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerAccount",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "enum ITokenPrice.PriceModifier",
                  "name": "priceModifier",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "priceModifierFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITokenPrice.TokenPriceData",
              "name": "initialPrice",
              "type": "tuple"
            }
          ],
          "indexed": false,
          "internalType": "struct IAirdropTokenSale.TokenSaleSettings",
          "name": "tokenSale",
          "type": "tuple"
        }
      ],
      "name": "TokenSaleClosed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenHash",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collectionHash",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "payee",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "openState",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerAccount",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "enum ITokenPrice.PriceModifier",
                  "name": "priceModifier",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "priceModifierFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITokenPrice.TokenPriceData",
              "name": "initialPrice",
              "type": "tuple"
            }
          ],
          "indexed": false,
          "internalType": "struct IAirdropTokenSale.TokenSaleSettings",
          "name": "tokenSale",
          "type": "tuple"
        }
      ],
      "name": "TokenSaleOpen",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "quantity",
          "type": "uint256"
        }
      ],
      "name": "TokenSaleSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenHash",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collectionHash",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "payee",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "openState",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerAccount",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "enum ITokenPrice.PriceModifier",
                  "name": "priceModifier",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "priceModifierFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITokenPrice.TokenPriceData",
              "name": "initialPrice",
              "type": "tuple"
            }
          ],
          "indexed": false,
          "internalType": "struct IAirdropTokenSale.TokenSaleSettings",
          "name": "tokenSale",
          "type": "tuple"
        }
      ],
      "name": "TokenSaleSettingsUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "salePrice",
          "type": "uint256"
        }
      ],
      "name": "TokenSold",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address payable",
              "name": "receiver",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sourceToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "sourceTokenId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "quantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "price",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "quantitySold",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct ITokenSale.TokenSaleEntry",
          "name": "tokens",
          "type": "tuple"
        }
      ],
      "name": "TokensSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokensaleId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenHash",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collectionHash",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "payee",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "openState",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerAccount",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "enum ITokenPrice.PriceModifier",
                  "name": "priceModifier",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "priceModifierFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITokenPrice.TokenPriceData",
              "name": "initialPrice",
              "type": "tuple"
            }
          ],
          "indexed": false,
          "internalType": "struct IAirdropTokenSale.TokenSaleSettings",
          "name": "settings",
          "type": "tuple"
        }
      ],
      "name": "TokensaleCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "airdropRedeemed",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenHash",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collectionHash",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "payee",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "openState",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerAccount",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "enum ITokenPrice.PriceModifier",
                  "name": "priceModifier",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "priceModifierFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITokenPrice.TokenPriceData",
              "name": "initialPrice",
              "type": "tuple"
            }
          ],
          "internalType": "struct IAirdropTokenSale.TokenSaleSettings",
          "name": "tokenSaleInit",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bool",
              "name": "whitelistOnly",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "whitelistId",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "whitelistHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerAccount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "quantitySold",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "enum ITokenPrice.PriceModifier",
                  "name": "priceModifier",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "priceModifierFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITokenPrice.TokenPriceData",
              "name": "initialPrice",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "tokenHash",
              "type": "uint256"
            }
          ],
          "internalType": "struct IAirdrop.AirdropSettings[]",
          "name": "settingsList",
          "type": "tuple[]"
        }
      ],
      "name": "createTokenSale",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        }
      ],
      "name": "getTokenSaleSettings",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenHash",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collectionHash",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "payee",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "openState",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerAccount",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "enum ITokenPrice.PriceModifier",
                  "name": "priceModifier",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "priceModifierFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITokenPrice.TokenPriceData",
              "name": "initialPrice",
              "type": "tuple"
            }
          ],
          "internalType": "struct IAirdropTokenSale.TokenSaleSettings",
          "name": "settings",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "whitelistOnly",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "whitelistId",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "whitelistHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerAccount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "quantitySold",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "enum ITokenPrice.PriceModifier",
                  "name": "priceModifier",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "priceModifierFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITokenPrice.TokenPriceData",
              "name": "initialPrice",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "tokenHash",
              "type": "uint256"
            }
          ],
          "internalType": "struct IAirdrop.AirdropSettings",
          "name": "_airdrop",
          "type": "tuple"
        }
      ],
      "name": "newAirdrop",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "quantity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "drop",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "merkleProof",
          "type": "bytes32[]"
        }
      ],
      "name": "purchase",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "drop",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "leaf",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "merkleProof",
          "type": "bytes32[]"
        }
      ],
      "name": "redeemToken",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenSaleId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenHash",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collectionHash",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "payee",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "openState",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minQuantityPerSale",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxQuantityPerAccount",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "enum ITokenPrice.PriceModifier",
                  "name": "priceModifier",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "priceModifierFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITokenPrice.TokenPriceData",
              "name": "initialPrice",
              "type": "tuple"
            }
          ],
          "internalType": "struct IAirdropTokenSale.TokenSaleSettings",
          "name": "settings",
          "type": "tuple"
        }
      ],
      "name": "updateTokenSaleSettings",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf0ce3eba7efeab91b6fcfa3dbd1816d7e2f3d616b1ff9e10aaa75cfa41356fb9",
  "receipt": {
    "to": null,
    "from": "0x97AEd3F8aaCbcB22b374aC49bC2354374f17235a",
    "contractAddress": "0xde2aEa52dC5DF3515A064a07Fee0130DD17112B3",
    "transactionIndex": 25,
    "gasUsed": "1902471",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc8195a0f8176f93dac3b29b264b3ddc7bf206d462f516099959ae2b03334765e",
    "transactionHash": "0xf0ce3eba7efeab91b6fcfa3dbd1816d7e2f3d616b1ff9e10aaa75cfa41356fb9",
    "logs": [],
    "blockNumber": 10568995,
    "cumulativeGasUsed": "8584536",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "af54060ac13cd822e4c3f0f7494b07aa",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"airdropId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AirdropRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"}],\"name\":\"PowerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"TokenPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectionHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"openState\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenPrice.PriceModifier\",\"name\":\"priceModifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceModifierFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenPrice.TokenPriceData\",\"name\":\"initialPrice\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct IAirdropTokenSale.TokenSaleSettings\",\"name\":\"tokenSale\",\"type\":\"tuple\"}],\"name\":\"TokenSaleClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectionHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"openState\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenPrice.PriceModifier\",\"name\":\"priceModifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceModifierFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenPrice.TokenPriceData\",\"name\":\"initialPrice\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct IAirdropTokenSale.TokenSaleSettings\",\"name\":\"tokenSale\",\"type\":\"tuple\"}],\"name\":\"TokenSaleOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"TokenSaleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectionHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"openState\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenPrice.PriceModifier\",\"name\":\"priceModifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceModifierFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenPrice.TokenPriceData\",\"name\":\"initialPrice\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct IAirdropTokenSale.TokenSaleSettings\",\"name\":\"tokenSale\",\"type\":\"tuple\"}],\"name\":\"TokenSaleSettingsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sourceTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantitySold\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ITokenSale.TokenSaleEntry\",\"name\":\"tokens\",\"type\":\"tuple\"}],\"name\":\"TokensSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokensaleId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectionHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"openState\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenPrice.PriceModifier\",\"name\":\"priceModifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceModifierFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenPrice.TokenPriceData\",\"name\":\"initialPrice\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct IAirdropTokenSale.TokenSaleSettings\",\"name\":\"settings\",\"type\":\"tuple\"}],\"name\":\"TokensaleCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"airdropRedeemed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectionHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"openState\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenPrice.PriceModifier\",\"name\":\"priceModifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceModifierFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenPrice.TokenPriceData\",\"name\":\"initialPrice\",\"type\":\"tuple\"}],\"internalType\":\"struct IAirdropTokenSale.TokenSaleSettings\",\"name\":\"tokenSaleInit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"whitelistOnly\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"whitelistId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"whitelistHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerAccount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantitySold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenPrice.PriceModifier\",\"name\":\"priceModifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceModifierFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenPrice.TokenPriceData\",\"name\":\"initialPrice\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenHash\",\"type\":\"uint256\"}],\"internalType\":\"struct IAirdrop.AirdropSettings[]\",\"name\":\"settingsList\",\"type\":\"tuple[]\"}],\"name\":\"createTokenSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"}],\"name\":\"getTokenSaleSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectionHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"openState\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenPrice.PriceModifier\",\"name\":\"priceModifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceModifierFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenPrice.TokenPriceData\",\"name\":\"initialPrice\",\"type\":\"tuple\"}],\"internalType\":\"struct IAirdropTokenSale.TokenSaleSettings\",\"name\":\"settings\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"whitelistOnly\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"whitelistId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"whitelistHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerAccount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantitySold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenPrice.PriceModifier\",\"name\":\"priceModifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceModifierFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenPrice.TokenPriceData\",\"name\":\"initialPrice\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenHash\",\"type\":\"uint256\"}],\"internalType\":\"struct IAirdrop.AirdropSettings\",\"name\":\"_airdrop\",\"type\":\"tuple\"}],\"name\":\"newAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"drop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"drop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leaf\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"redeemToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSaleId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectionHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"openState\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuantityPerSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenPrice.PriceModifier\",\"name\":\"priceModifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceModifierFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenPrice.TokenPriceData\",\"name\":\"initialPrice\",\"type\":\"tuple\"}],\"internalType\":\"struct IAirdropTokenSale.TokenSaleSettings\",\"name\":\"settings\",\"type\":\"tuple\"}],\"name\":\"updateTokenSaleSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createTokenSale((address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)),(bool,uint256,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256),uint256)[])\":{\"params\":{\"tokenSaleInit\":\"struct with tokensale data\"}},\"newAirdrop((bool,uint256,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256),uint256))\":{\"params\":{\"_airdrop\":\"the id of the airdrop\"}},\"redeemToken(uint256,uint256,uint256,address,uint256,uint256,bytes32[])\":{\"params\":{\"amount\":\"- the seed\",\"drop\":\"- the address of the account receiving the item\",\"leaf\":\"- the seed\",\"merkleProof\":\"- the seed\",\"recipient\":\"- the seed\"}},\"updateTokenSaleSettings(uint256,(address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)))\":{\"params\":{\"settings\":\"- the token sake settings\"}}},\"version\":1},\"userdoc\":{\"events\":{\"TokenPurchased(uint256,address,uint256,uint256)\":{\"notice\":\"emitted when a token is opened\"},\"TokenSaleClosed(uint256,(address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)))\":{\"notice\":\"emitted when a token is opened\"},\"TokenSaleOpen(uint256,(address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)))\":{\"notice\":\"emitted when a token is opened\"}},\"kind\":\"user\",\"methods\":{\"createTokenSale((address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)),(bool,uint256,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256),uint256)[])\":{\"notice\":\"intialize the contract. should be called by overriding contract\"},\"getTokenSaleSettings(uint256)\":{\"notice\":\"Get the token sale settings\"},\"newAirdrop((bool,uint256,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256),uint256))\":{\"notice\":\"add a new airdrop\"},\"updateTokenSaleSettings(uint256,(address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)))\":{\"notice\":\"Updates the token sale settings\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/AirdropTokenSaleFacet.sol\":\"AirdropTokenSaleFacet\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":5},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x8e93de94c9062ebc94fb7e2e3929b0781ac6a2b7772e2f7a59045861c93e5be9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/access/Controllable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../interfaces/IControllable.sol\\\";\\n\\nabstract contract Controllable is IControllable {\\n    mapping(address => bool) internal _controllers;\\n\\n    /**\\n     * @dev Throws if called by any account not in authorized list\\n     */\\n    modifier onlyController() virtual {\\n        require(\\n            _controllers[msg.sender] == true || address(this) == msg.sender,\\n            \\\"Controllable: caller is not a controller\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Add an address allowed to control this contract\\n     */\\n    function addController(address _controller)\\n        external\\n        override\\n        onlyController\\n    {\\n        _addController(_controller);\\n    }\\n    function _addController(address _controller) internal {\\n        _controllers[_controller] = true;\\n    }\\n\\n    /**\\n     * @dev Check if this address is a controller\\n     */\\n    function isController(address _address)\\n        external\\n        view\\n        override\\n        returns (bool allowed)\\n    {\\n        allowed = _isController(_address);\\n    }\\n    function _isController(address _address)\\n        internal view\\n        returns (bool allowed)\\n    {\\n        allowed = _controllers[_address];\\n    }\\n\\n    /**\\n     * @dev Remove the sender address from the list of controllers\\n     */\\n    function relinquishControl() external override onlyController {\\n        _relinquishControl();\\n    }\\n    function _relinquishControl() internal onlyController{\\n        delete _controllers[msg.sender];\\n    }\\n}\\n\",\"keccak256\":\"0x3ec41d0cba41ef15351073a2abf5d76ba26ff568989ccc0d2dd654dc9d24f1d8\",\"license\":\"MIT\"},\"contracts/diamond/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/UInt256Set.sol\\\";\\nimport \\\"../utils/AddressSet.sol\\\";\\n\\nimport \\\"../interfaces/IMarketplace.sol\\\";\\nimport \\\"../interfaces/ITokenMinter.sol\\\";\\nimport \\\"../interfaces/ITokenSale.sol\\\";\\nimport \\\"../interfaces/IForge.sol\\\";\\nimport \\\"../interfaces/IGemPool.sol\\\";\\nimport \\\"../interfaces/IClaim.sol\\\";\\nimport \\\"../interfaces/IRequirement.sol\\\";\\nimport \\\"../interfaces/IAirdropTokenSale.sol\\\";\\nimport \\\"../interfaces/IERC721A.sol\\\";\\n\\nimport {LibDiamond} from \\\"./LibDiamond.sol\\\";\\n\\nstruct SvgLayer {\\n    address svgLayersContract;\\n    uint16 offset;\\n    uint16 size;\\n}\\n\\n\\nstruct GemPoolStorage {\\n    // gem pools data\\n    mapping(uint256 => IGemPool.GemPoolStruct) _gemPools;\\n    // record hashes created by the gem pools\\n    mapping(uint256 => UInt256Set.Set) _recordHashes;\\n    // gem requirements banked within the gem pool\\n    mapping(uint256 => IToken.Token[]) _bankedRequirements;\\n    // claim data\\n    mapping(uint256 => IClaim.Claim) _claims;\\n    uint256 _claimIndex;\\n    // staked totals\\n    mapping(address => uint256) _stakedTotal;\\n    //requirement data\\n    IRequirement.RequirementData _requirementData;\\n    // all symbols listed in the gem pool\\n    string[] _symbols;\\n}\\n\\nstruct ForgeStorage {\\n    // the forge settings by forge id\\n    mapping(uint256 => ForgeDefinition) forges;\\n    uint256[] forgeIds;\\n    // the forge item settings by forge item id\\n    mapping(uint256 => mapping(uint256 => ForgeItemDefinition)) forgeItems;\\n    uint256[] forgeItemIds;\\n    // forged item hashes by forge id\\n    mapping(uint256 => UInt256Set.Set) forgedItemHashes;\\n    // all forged item hashes\\n    UInt256Set.Set allforgedItemHashes;\\n    // all forge symbols\\n    string[] symbols;\\n}\\n\\n// struct for erc1155 storage\\nstruct ERC1155Storage {\\n    mapping(uint256 => mapping(address => uint256)) _balances;\\n    mapping(address => mapping(address => bool)) _operatorApprovals;\\n    mapping(address => mapping(uint256 => uint256)) _minterApprovals;\\n\\n    // mono-uri from erc1155\\n    string _uri;\\n    string _uriBase;\\n    string _symbol;\\n    string _name;\\n\\n    address _approvalProxy;\\n}\\n\\n// struct for erc721a storage\\nstruct ERC721AStorage {\\n    // The tokenId of the next token to be minted.\\n    uint256 _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 _burnCounter;\\n\\n    // Token name\\n    string _name;\\n\\n    // Token symbol\\n    string _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\\n    mapping(uint256 => IERC721A.TokenOwnership) _ownerships;\\n\\n    // Mapping owner address to address data\\n    mapping(address => IERC721A.AddressData) _addressData;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) _operatorApprovals;\\n}\\n\\n// erc2981 storage struct\\nstruct ERC2981Storage {\\n    // royalty receivers by token hash\\n    mapping(uint256 => address) royaltyReceiversByHash;\\n    // royalties for each token hash - expressed as permilliage of total supply\\n    mapping(uint256 => uint256) royaltyFeesByHash;\\n}\\n\\n// attribute mutatiom pool storage\\nstruct AttributeMutationPoolStorage {\\n    string _attributeKey;\\n    uint256 _attributeValuePerPeriod;\\n    uint256 _attributeBlocksPerPeriod;\\n    uint256 _totalValueThreshold;\\n    mapping (address => mapping (uint256 => uint256)) _tokenDepositHeight;\\n}\\n\\n// token attribute storage\\nstruct TokenAttributeStorage {\\n    mapping(uint256 => mapping(string => uint256)) attributes;\\n}\\n\\n// merkle utils storage\\nstruct MerkleUtilsStorage {\\n    mapping(uint256 => uint256) tokenHashToIds;\\n}\\n\\n// NFT marketplace storage\\nstruct MarketplaceStorage {\\n    uint256 itemsSold;\\n    uint256 itemIds;\\n    mapping(uint256 => IMarketplace.MarketItem) idToMarketItem;\\n    mapping(uint256 => bool) idToListed;\\n}\\n\\n// token minter storage\\nstruct TokenMinterStorage {\\n    address token;\\n    uint256 _tokenCounter;\\n    mapping(uint256 => address) _tokenMinters;\\n}\\n\\n// fractionalized token storage\\nstruct FractionalizedTokenData {\\n    string symbol;\\n    string name;\\n    address tokenAddress;\\n    uint256 tokenId;\\n    address fractionalizedToken;\\n    uint256 totalFractions;\\n}\\n\\n// fractionalizer storage\\nstruct FractionalizerStorage {\\n    address fTokenTemplate;\\n    mapping(address => FractionalizedTokenData) fractionalizedTokens;\\n}\\n\\n// token sale storage\\nstruct TokenSaleStorage {\\n    mapping(address => ITokenSale.TokenSaleEntry) tokenSaleEntries;\\n}\\n\\n// fee manager storage\\nstruct FeeManagerStorage {\\n    mapping(string => uint256) _fees;\\n}\\n\\nstruct AirdropTokenSaleStorage {\\n    uint256 tsnonce;\\n    mapping(uint256 => uint256) nonces;\\n    // token sale settings\\n    mapping(uint256 => IAirdropTokenSale.TokenSaleSettings) _tokenSales;\\n    // is token sale open\\n    mapping(uint256 => bool) tokenSaleOpen;\\n    // total purchased tokens per drop - 0 for public tokensale\\n    mapping(uint256 => mapping(address => uint256)) purchased;\\n    // total purchased tokens per drop - 0 for public tokensale\\n    mapping(uint256 => uint256) totalPurchased;\\n}\\n\\nstruct MerkleAirdropStorage {\\n    mapping (uint256 => IAirdrop.AirdropSettings) _settings;\\n    uint256 numSettings;\\n    mapping (uint256 => mapping(uint256 => uint256)) _redeemedData;\\n    mapping (uint256 => mapping(address => uint256)) _redeemedDataQuantities;\\n    mapping (uint256 => mapping(address => uint256)) _totalDataQuantities;\\n}\\n\\nstruct MarketUtilsStorage {\\n    mapping(uint256 => bool) validTokens;\\n}\\n\\nstruct BankStorage {\\n    address token;\\n    mapping(address => mapping(uint256 => uint256)) balances;\\n}\\n\\n\\nstruct AppStorage {\\n    // gem pools data\\n    MarketplaceStorage marketplaceStorage;\\n    // gem pools data\\n    TokenMinterStorage tokenMinterStorage;\\n    // the erc1155 token\\n    ERC1155Storage erc1155Storage;\\n    // fractionalizer storage\\n    FractionalizerStorage fractionalizerStorage;\\n    // market utils storage\\n    MarketUtilsStorage marketUtilsStorage;\\n    // token sale storage\\n    TokenSaleStorage tokenSaleStorage;\\n    // merkle airdrop storage\\n    MerkleAirdropStorage merkleAirdropStorage;\\n    // erc721a storage\\n    ERC721AStorage erc721AStorage;\\n    // erc2981 storage\\n    ERC2981Storage erc2981Storage;\\n    // attribute mutation pool storage\\n    AttributeMutationPoolStorage attributeMutationPoolStorage;\\n    // token attribute storage\\n    TokenAttributeStorage tokenAttributeStorage;\\n    // airdrop token sale storage\\n    AirdropTokenSaleStorage airdropTokenSaleStorage;\\n    // fee manager storage\\n    FeeManagerStorage feeManagerStorage;\\n    // bank storage\\n    BankStorage bankStorage;\\n    // forge storage\\n    ForgeStorage forgeStorage;\\n    // gem pool storage\\n    GemPoolStorage gemPoolStorage;\\n}\\n\\nlibrary LibAppStorage {\\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\\n        assembly {\\n            ds.slot := 0\\n        }\\n    }\\n}\\n\\ncontract Modifiers {\\n    AppStorage internal s;\\n    modifier onlyOwner() {\\n        require(LibDiamond.contractOwner() == msg.sender || address(this) == msg.sender, \\\"ERC1155: only the contract owner can call this function\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x0b18cf449788484d54202277232fcd5789728936344db6625daa3a6b00dbfd6f\",\"license\":\"MIT\"},\"contracts/diamond/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n/// @notice Defines the data structures that are used to store the data for a diamond\\nlibrary LibDiamond {\\n    // the diamond storage position\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    /// @notice Stores the function selectors located within the Diamond\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    /// @notice Returns the storage position of the diamond\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    // event is generated when the diamond ownership is transferred\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice set the diamond contract owner\\n    /// @param _newOwner the new owner of the diamond\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    /// @notice returns the diamond contract owner\\n    /// @return contractOwner_ the diamond contract owner\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    /// @notice enforce contract ownership by requiring the caller to be the contract owner\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /// @notice add or replace facet selectors\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n            // \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(address(bytes20(oldFacet)) != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n                    // only useful if immutable functions exist\\n                    require(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    // \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    // \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    /// @notice initialise the DiamondCut contract\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0xdec0822acba9b539929f2c34457a02138bd28fd083a8feefb10a65e554f0124a\",\"license\":\"MIT\"},\"contracts/facets/AirdropTokenSaleFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport \\\"./MerkleAirdropFacet.sol\\\";\\n\\nimport \\\"../access/Controllable.sol\\\";\\n\\nimport \\\"../interfaces/IAirdrop.sol\\\";\\n\\nimport \\\"../interfaces/IERC1155Mint.sol\\\";\\n\\nimport \\\"../interfaces/IERC20Mint.sol\\\";\\n\\nimport \\\"../interfaces/IAirdropTokenSale.sol\\\";\\n\\nimport \\\"../interfaces/IPower.sol\\\";\\n\\nimport {IMerkleAirdropRedeemer} from \\\"./MerkleAirdropFacet.sol\\\";\\n\\ninterface IERC2981Setter {\\n    function setRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint256 amount\\n    ) external;\\n}\\n\\ninterface IMerkleAirdropAdder {\\n    function addAirdrop(IAirdrop.AirdropSettings memory _airdrop) external;\\n}\\n\\ncontract AirdropTokenSaleFacet is\\n    ITokenSale,\\n    Modifiers,\\n    IPower // returns the chain id\\n{\\n    /// @notice emitted when a token is opened\\n    event TokenSaleOpen(\\n        uint256 tokenSaleId,\\n        IAirdropTokenSale.TokenSaleSettings tokenSale\\n    );\\n\\n    /// @notice emitted when a token is opened\\n    event TokenSaleClosed(\\n        uint256 tokenSaleId,\\n        IAirdropTokenSale.TokenSaleSettings tokenSale\\n    );\\n\\n    /// @notice emitted when a token is opened\\n    event TokenPurchased(\\n        uint256 tokenSaleId,\\n        address indexed purchaser,\\n        uint256 tokenId,\\n        uint256 quantity\\n    );\\n\\n    // token settings were updated\\n    event TokenSaleSettingsUpdated(\\n        uint256 tokenSaleId,\\n        IAirdropTokenSale.TokenSaleSettings tokenSale\\n    );\\n\\n    event TokensaleCreated(\\n        uint256 indexed tokensaleId,\\n        IAirdropTokenSale.TokenSaleSettings settings\\n    );\\n    event AirdropRedeemed(\\n        uint256 indexed airdropId,\\n        address indexed beneficiary,\\n        bytes32[] proof,\\n        uint256 amount\\n    );\\n\\n    using UInt256Set for UInt256Set.Set;\\n\\n    /// @notice intialize the contract. should be called by overriding contract\\n    /// @param tokenSaleInit struct with tokensale data\\n    function createTokenSale(\\n        IAirdropTokenSale.TokenSaleSettings memory tokenSaleInit,\\n        IAirdrop.AirdropSettings[] calldata settingsList\\n    ) public virtual returns (uint256 tokenSaleId) {\\n        // sanity check input values\\n        require(\\n            tokenSaleInit.token != address(0),\\n            \\\"Multitoken address must be set\\\"\\n        );\\n        if (settingsList.length > 0)\\n            IMerkleAirdrop(address(this)).initMerkleAirdrops(settingsList);\\n        // set settings object\\n        tokenSaleId = uint256(\\n            keccak256(\\n                abi.encodePacked(\\n                    s.airdropTokenSaleStorage.tsnonce,\\n                    address(this)\\n                )\\n            )\\n        );\\n        s.airdropTokenSaleStorage._tokenSales[\\n            uint256(tokenSaleId)\\n        ] = tokenSaleInit;\\n        s\\n            .airdropTokenSaleStorage\\n            ._tokenSales[uint256(tokenSaleId)]\\n            .contractAddress = address(this);\\n        emit TokensaleCreated(tokenSaleId, tokenSaleInit);\\n    }\\n\\n    /// @notice Called to purchase some quantity of a token. Assumes no airdrop / no whitelist\\n    /// @param receiver - the address of the account receiving the item\\n    /// @param _drop - the seed\\n    function _purchase(\\n        uint256 tokenSaleId,\\n        uint256 _drop,\\n        address receiver\\n    ) internal returns (uint256) {\\n        // request (mint) the tokens. This method must be overridden\\n        uint256 tokenHash;\\n        if (_drop != 0) {\\n            require(\\n                s.merkleAirdropStorage._settings[_drop].whitelistId == _drop,\\n                \\\"Airdrop doesnt exist\\\"\\n            );\\n            tokenHash = s.merkleAirdropStorage._settings[_drop].tokenHash;\\n        } else {\\n            tokenHash = s\\n                .airdropTokenSaleStorage\\n                ._tokenSales[tokenSaleId]\\n                .tokenHash;\\n        }\\n        // check the token hash, make one if source is zero\\n        if (tokenHash == 0) {\\n            s.airdropTokenSaleStorage.nonces[tokenSaleId] =\\n                s.airdropTokenSaleStorage.nonces[tokenSaleId] +\\n                1;\\n            tokenHash = uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"airdropTokenSale\\\",\\n                        receiver,\\n                        tokenSaleId,\\n                        s.airdropTokenSaleStorage.nonces[tokenSaleId]\\n                    )\\n                )\\n            );\\n        }\\n        // mint a token to the user\\n        this.airdropRedeemed(\\n            tokenSaleId,\\n            _drop,\\n            receiver,\\n            1\\n        );\\n\\n        // increase total bought\\n        s.airdropTokenSaleStorage.totalPurchased[_drop] += 1;\\n        s.airdropTokenSaleStorage.purchased[_drop][receiver] += 1;\\n\\n        // emit a message about the purchase\\n        emit TokenPurchased(tokenSaleId, receiver, tokenHash, 1);\\n        return tokenHash;\\n    }\\n\\n    function purchase(\\n        uint256 tokenSaleId,\\n        address receiver,\\n        uint256 quantity,\\n        uint256 total,\\n        uint256 drop,\\n        uint256 index,\\n        bytes32[] memory merkleProof\\n    ) external payable {\\n        _purchaseToken(\\n            tokenSaleId,\\n            receiver,\\n            quantity,\\n            total,\\n            drop,\\n            index,\\n            merkleProof,\\n            msg.value\\n        );\\n    }\\n\\n    /// @notice Called to purchase some quantity of a token\\n    /// @param receiver - the address of the account receiving the item\\n    /// @param quantity - the seed\\n    /// @param drop - the seed\\n    /// @param leaf - the seed\\n    /// @param merkleProof - the seed\\n    function _purchaseToken(\\n        uint256 tokenSaleId,\\n        address receiver,\\n        uint256 quantity,\\n        uint256 total,\\n        uint256 drop,\\n        uint256 leaf,\\n        bytes32[] memory merkleProof,\\n        uint256 valueAttached\\n    ) internal {\\n        // only check for a non-zero drop id\\n        if (drop != 0) {\\n            IAirdrop.AirdropSettings storage _drop = s\\n                .merkleAirdropStorage\\n                ._settings[drop];\\n            // check that the airdrop is valid\\n            require(_drop.whitelistId == drop, \\\"Airdrop doesnt exist\\\");\\n            // check that the airdrop is valid\\n            require(\\n                !IMerkleAirdrop(address(this)).airdropRedeemed(drop, receiver),\\n                \\\"Airdrop already redeemed\\\"\\n            );\\n            // make sure there are still tokens to purchase\\n            require(\\n                _drop.maxQuantity == 0 ||\\n                    (_drop.maxQuantity != 0 &&\\n                        _drop.quantitySold + quantity <= _drop.maxQuantity),\\n                \\\"The maximum amount of tokens has been bought.\\\"\\n            );\\n            // enough price is attached\\n            require(\\n                _drop.initialPrice.price * quantity <= valueAttached,\\n                \\\"Not enough price attached\\\"\\n            );\\n            // make sure the max qty per sale is not exceeded\\n            require(\\n                _drop.minQuantityPerSale == 0 ||\\n                    (_drop.minQuantityPerSale != 0 &&\\n                        quantity >= _drop.minQuantityPerSale),\\n                \\\"Minimum quantity per sale not met\\\"\\n            );\\n            // make sure the max qty per sale is not exceeded\\n            require(\\n                _drop.maxQuantityPerSale == 0 ||\\n                    (_drop.maxQuantityPerSale != 0 &&\\n                        quantity <= _drop.maxQuantityPerSale),\\n                \\\"Maximum quantity per sale exceeded\\\"\\n            );\\n            // make sure the token sale has started\\n            require(\\n                block.timestamp >= _drop.startTime || _drop.startTime == 0,\\n                \\\"The sale has not started yet\\\"\\n            );\\n            // make sure token sale is not over\\n            require(\\n                block.timestamp <= _drop.endTime || _drop.endTime == 0,\\n                \\\"The sale has ended\\\"\\n            );\\n            // only enforce the whitelist if explicitly set\\n            if (_drop.whitelistOnly) {\\n                // redeem the airdrop slot and then purchase an NFT\\n                IMerkleAirdropRedeemer(address(this)).redeemAirdrop(\\n                    drop,\\n                    leaf,\\n                    receiver,\\n                    quantity,\\n                    total,\\n                    merkleProof\\n                );\\n            }\\n            for (uint256 i = 0; i < quantity; i++) {\\n                _purchase(tokenSaleId, drop, receiver);\\n                emit AirdropRedeemed(\\n                    drop,\\n                    receiver,\\n                    merkleProof,\\n                    quantity\\n                );\\n            }\\n        } else {\\n            // make sure there are still tokens to purchase\\n            require(\\n                s\\n                    .airdropTokenSaleStorage\\n                    ._tokenSales[tokenSaleId]\\n                    .maxQuantity ==\\n                    0 ||\\n                    (s\\n                        .airdropTokenSaleStorage\\n                        ._tokenSales[tokenSaleId]\\n                        .maxQuantity !=\\n                        0 &&\\n                        s.airdropTokenSaleStorage.totalPurchased[0] <\\n                        s\\n                            .airdropTokenSaleStorage\\n                            ._tokenSales[tokenSaleId]\\n                            .maxQuantity),\\n                \\\"The maximum amount of tokens has been bought.\\\"\\n            );\\n            // make sure the max qty per sale is not exceeded\\n            require(\\n                s\\n                    .airdropTokenSaleStorage\\n                    ._tokenSales[tokenSaleId]\\n                    .minQuantityPerSale ==\\n                    0 ||\\n                    (s\\n                        .airdropTokenSaleStorage\\n                        ._tokenSales[tokenSaleId]\\n                        .minQuantityPerSale !=\\n                        0 &&\\n                        quantity >=\\n                        s\\n                            .airdropTokenSaleStorage\\n                            ._tokenSales[tokenSaleId]\\n                            .minQuantityPerSale),\\n                \\\"Minimum quantity per sale not met\\\"\\n            );\\n            // make sure the max qty per sale is not exceeded\\n            require(\\n                s\\n                    .airdropTokenSaleStorage\\n                    ._tokenSales[tokenSaleId]\\n                    .maxQuantityPerSale ==\\n                    0 ||\\n                    (s\\n                        .airdropTokenSaleStorage\\n                        ._tokenSales[tokenSaleId]\\n                        .maxQuantityPerSale !=\\n                        0 &&\\n                        quantity <=\\n                        s\\n                            .airdropTokenSaleStorage\\n                            ._tokenSales[tokenSaleId]\\n                            .maxQuantityPerSale),\\n                \\\"Maximum quantity per sale exceeded\\\"\\n            );\\n            // make sure token sale is started\\n            // TODO: Need to revisit this logic\\n            require(\\n                block.timestamp >=\\n                    s\\n                        .airdropTokenSaleStorage\\n                        ._tokenSales[tokenSaleId]\\n                        .startTime ||\\n                    s\\n                        .airdropTokenSaleStorage\\n                        ._tokenSales[tokenSaleId]\\n                        .startTime ==\\n                    0,\\n                \\\"The sale has not started yet\\\"\\n            );\\n            // make sure token sale is not over\\n            // TODO: Need to revisit this logic\\n            require(\\n                block.timestamp <=\\n                    s\\n                        .airdropTokenSaleStorage\\n                        ._tokenSales[tokenSaleId]\\n                        .endTime ||\\n                    s\\n                        .airdropTokenSaleStorage\\n                        ._tokenSales[tokenSaleId]\\n                        .endTime ==\\n                    0,\\n                \\\"The sale has ended\\\"\\n            );\\n            // purchase a NFT\\n            for (uint256 i = 0; i < quantity; i++) {\\n                _purchase(tokenSaleId, drop, receiver);\\n            }\\n        }\\n    }\\n\\n    // @notice Called to redeem some quantity of a token - same as purchase\\n    /// @param drop - the address of the account receiving the item\\n    /// @param leaf - the seed\\n    /// @param recipient - the seed\\n    /// @param amount - the seed\\n    /// @param merkleProof - the seed\\n    function redeemToken(\\n        uint256 tokenSaleId,\\n        uint256 drop,\\n        uint256 leaf,\\n        address recipient,\\n        uint256 amount,\\n        uint256 total,\\n        bytes32[] memory merkleProof\\n    ) public payable {\\n        _purchaseToken(\\n            tokenSaleId,\\n            recipient,\\n            amount,\\n            total,\\n            drop,\\n            leaf,\\n            merkleProof,\\n            msg.value\\n        );\\n    }\\n\\n    function airdropRedeemed(\\n        uint256 tokenSaleId,\\n        uint256,\\n        address recipient,\\n        uint256 amount\\n    ) external {\\n        // mint the token\\n        IERC20Mint(s.airdropTokenSaleStorage._tokenSales[tokenSaleId].token)\\n            .mint(recipient, amount);\\n    }\\n\\n    /// @notice Get the token sale settings\\n    function getTokenSaleSettings(uint256 tokenSaleId)\\n        external\\n        view\\n        virtual\\n        returns (IAirdropTokenSale.TokenSaleSettings memory settings)\\n    {\\n        settings = IAirdropTokenSale.TokenSaleSettings(\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].contractAddress,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].token,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].tokenHash,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].collectionHash,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].owner,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].payee,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].symbol,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].name,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].description,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].openState,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].startTime,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].endTime,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].maxQuantity,\\n            s\\n                .airdropTokenSaleStorage\\n                ._tokenSales[tokenSaleId]\\n                .maxQuantityPerSale,\\n            s\\n                .airdropTokenSaleStorage\\n                ._tokenSales[tokenSaleId]\\n                .minQuantityPerSale,\\n            s\\n                .airdropTokenSaleStorage\\n                ._tokenSales[tokenSaleId]\\n                .maxQuantityPerAccount,\\n            s.airdropTokenSaleStorage._tokenSales[tokenSaleId].initialPrice\\n        );\\n    }\\n\\n    /// @notice Updates the token sale settings\\n    /// @param settings - the token sake settings\\n    function updateTokenSaleSettings(\\n        uint256 tokenSaleId,\\n        IAirdropTokenSale.TokenSaleSettings memory settings\\n    ) external onlyOwner {\\n        require(\\n            msg.sender ==\\n                s.airdropTokenSaleStorage._tokenSales[tokenSaleId].owner,\\n            \\\"Only the owner can update the token sale settings\\\"\\n        );\\n        s.airdropTokenSaleStorage._tokenSales[tokenSaleId] = settings;\\n        emit TokenSaleSettingsUpdated(tokenSaleId, settings);\\n    }\\n\\n    /// @notice add a new airdrop\\n    /// @param _airdrop the id of the airdrop\\n    function newAirdrop(IAirdrop.AirdropSettings memory _airdrop)\\n        external\\n        onlyOwner\\n    {\\n        IMerkleAirdropAdder(address(this)).addAirdrop(_airdrop);\\n    }\\n}\\n\",\"keccak256\":\"0xd42f7508d0484ba84f3cb00f20a7ecf0eae6cef89323138bf5a96ea13c7af75c\",\"license\":\"MIT\"},\"contracts/facets/MerkleAirdropFacet.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.0;\\n\\nimport \\\"../diamond/LibAppStorage.sol\\\";\\nimport \\\"../interfaces/IAirdrop.sol\\\";\\nimport \\\"../utils/MerkleProof.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ninterface IMerkleAirdropRedeemer {\\n    function airdropRedeemed(\\n        uint256 tokenSaleId,\\n        uint256 drop,\\n        uint256 tokenHash,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n    function redeemAirdrop(\\n        uint256 drop,\\n        uint256 leaf,\\n        address recipient,\\n        uint256 amount,\\n        uint256 total,\\n        bytes32[] memory merkleProof\\n    ) external payable;\\n}\\n\\ncontract MerkleAirdropFacet is IAirdrop, Modifiers {\\n\\n    event AirdropAdded(\\n        uint256 tokenSaleId,\\n        uint256 drop\\n    );\\n\\n    /// @notice airdrops check to see if proof is redeemed\\n    /// @param drop the id of the airdrop\\n    /// @param redeemer the merkle proof\\n    /// @return isRedeemed the amount of tokens redeemed\\n    function airdropRedeemed(uint256 drop, address redeemer) external view override returns (bool isRedeemed) {\\n       isRedeemed = _airdropRedeemed(drop, redeemer);\\n    }\\n\\n    /// @notice airdrops check to see if proof is redeemed\\n    /// @param drop the id of the airdrop\\n    /// @param recipient the merkle proof\\n    /// @return isRedeemed the amount of tokens redeemed\\n    function _airdropRedeemed(uint256 drop, address recipient) internal view returns (bool isRedeemed) {\\n        uint256 red = s.merkleAirdropStorage._totalDataQuantities[drop][recipient];\\n        uint256 tot = s.merkleAirdropStorage._redeemedDataQuantities[drop][recipient]; // i\\n        return red != 0 && red == tot;\\n    }\\n\\n    /// @notice redeem tokens for airdrop\\n    /// @param drop the airdrop id\\n    /// @param leaf the index of the token in the airdrop\\n    /// @param recipient the beneficiary of the tokens\\n    /// @param amount tje amount of tokens to redeem\\n    /// @param merkleProof the merkle proof of the token\\n    function redeemAirdrop(\\n        uint256 drop,\\n        uint256 leaf,\\n        address recipient,\\n        uint256 amount,\\n        uint256 total,\\n        bytes32[] memory merkleProof\\n        ) external payable override onlyOwner {\\n\\n        // check to see if redeemed already\\n        uint256 _redeemedAmt = s.merkleAirdropStorage._redeemedDataQuantities[drop][recipient];\\n        uint256 _redeemedttl = s.merkleAirdropStorage._totalDataQuantities[drop][recipient];\\n        _redeemedttl = _redeemedAmt > 0 ? _redeemedttl : total;\\n\\n        require(_redeemedAmt + amount <= _redeemedttl, \\\"You have already redeemed this amount\\\");\\n        s.merkleAirdropStorage._totalDataQuantities[drop][recipient] = _redeemedttl;\\n        s.merkleAirdropStorage._redeemedDataQuantities[drop][recipient] += amount; // increment amount redeemed\\n\\n        bool valid = MerkleProof.verify(\\n            bytes32 (s.merkleAirdropStorage._settings[drop].whitelistHash),\\n            bytes32 (leaf),\\n            merkleProof\\n        );\\n\\n        // Check the merkle proof\\n        require(valid, \\\"Merkle proof failed\\\");\\n    }\\n\\n    /// @notice add a new airdrop\\n    /// @param _airdrop the id of the airdrop\\n    function addAirdrop(AirdropSettings memory _airdrop) public onlyOwner {\\n        require(s.merkleAirdropStorage._settings[uint256(_airdrop.whitelistId)].whitelistId != _airdrop.whitelistId, \\\"Airdrop already exists\\\");\\n        s.merkleAirdropStorage._settings[uint256(uint256(_airdrop.whitelistId))] = _airdrop;\\n    }\\n\\n    /// @notice Get the token sale settings\\n    /// @return settings the token sale settings\\n    function airdrop(uint256 drop) external view override returns (AirdropSettings memory settings) {\\n        require(s.merkleAirdropStorage._settings[drop].whitelistId == drop, \\\"Airdrop does not exist\\\");\\n        settings = s.merkleAirdropStorage._settings[drop];\\n    }\\n\\n    // init the airdrop, rejecting the tx if already initialized\\n    function initMerkleAirdrops(AirdropSettings[] calldata settingsList) public onlyOwner {\\n        require(s.merkleAirdropStorage.numSettings == 0, \\\"Airdrops already initialized\\\");\\n        require(settingsList.length > 0, \\\"No airdrops provided\\\");\\n\\n        for (uint256 i = 0; i < settingsList.length; i++) {\\n            addAirdrop(settingsList[i]);\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0xf3b434bc29f349b6c2da952d150d9b66f46345217e91a861ca02b28af5c69030\",\"license\":\"Unlicense\"},\"contracts/interfaces/IAirdrop.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IToken.sol\\\";\\nimport \\\"./ITokenPrice.sol\\\";\\n\\ninterface IMerkleAirdrop {\\n    function airdropRedeemed(\\n        uint256 drop,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n     function initMerkleAirdrops(IAirdrop.AirdropSettings[] calldata settingsList) external;\\n     function airdrop(uint256 drop) external view returns (IAirdrop.AirdropSettings memory settings);\\n     function airdropRedeemed(uint256 drop, address recipient) external view returns (bool isRedeemed);\\n}\\n\\n/// @notice an airdrop airdrops tokens\\ninterface IAirdrop {\\n\\n    // emitted when airdrop is redeemed\\n\\n\\n    /// @notice the settings for the token sale,\\n    struct AirdropSettings {\\n        // sell from the whitelist only\\n        bool whitelistOnly;\\n\\n        // this whitelist id - by convention is the whitelist hash\\n        uint256 whitelistId;\\n\\n        // the root hash of the merkle tree\\n        bytes32 whitelistHash;\\n\\n        // quantities\\n        uint256 maxQuantity; // max number of tokens that can be sold\\n        uint256 maxQuantityPerSale; // max number of tokens that can be sold per sale\\n        uint256 minQuantityPerSale; // min number of tokens that can be sold per sale\\n        uint256 maxQuantityPerAccount; // max number of tokens that can be sold per account\\n\\n        // quantity of item sold\\n        uint256 quantitySold;\\n\\n        // start timne and end time for token sale\\n        uint256 startTime; // block number when the sale starts\\n        uint256 endTime; // block number when the sale ends\\n\\n        // inital price of the token sale\\n        ITokenPrice.TokenPriceData initialPrice;\\n\\n        // token hash\\n        uint256 tokenHash;\\n    }\\n\\n    // emitted when airdrop is launched\\n    event AirdropLaunched(uint256 indexed airdropId, AirdropSettings airdrop);\\n\\n    // emitted when airdrop is redeemed\\n    event AirdropRedeemed(uint256 indexed airdropId, address indexed beneficiary, uint256 indexed tokenHash, bytes32[] proof, uint256 amount);\\n\\n    /// @notice airdrops check to see if proof is redeemed\\n    /// @param drop the id of the airdrop\\n    /// @param recipient the merkle proof\\n    /// @return isRedeemed the amount of tokens redeemed\\n    function airdropRedeemed(uint256 drop, address recipient) external view returns (bool isRedeemed);\\n\\n    /// @notice redeem tokens for airdrop\\n    /// @param drop the airdrop id\\n    /// @param leaf the index of the token in the airdrop\\n    /// @param recipient the beneficiary of the tokens\\n    /// @param amount tje amount of tokens to redeem\\n    /// @param merkleProof the merkle proof of the token\\n    function redeemAirdrop(uint256 drop, uint256 leaf, address recipient, uint256 amount, uint256 total, bytes32[] memory merkleProof) external payable;\\n\\n    /// @notice Get the token sale settings\\n    /// @return settings the token sale settings\\n    function airdrop(uint256 drop) external view returns (AirdropSettings memory settings);\\n\\n}\\n\",\"keccak256\":\"0x058706dad235147fd5fec33d11649a2bf16dc9164dd4fae53d68b8af5b8ba8f4\",\"license\":\"Unlicense\"},\"contracts/interfaces/IAirdropTokenSale.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ITokenPrice.sol\\\";\\nimport \\\"./IAirdrop.sol\\\";\\n\\n/// @notice A token seller is a contract that can sell tokens to a token buyer.\\n/// The token buyer can buy tokens from the seller by paying a certain amount\\n/// of base currency to receive a certain amount of erc1155 tokens. the number\\n/// of tokens that can be bought is limited by the seller - the seller can\\n/// specify the maximum number of tokens that can be bought per transaction\\n/// and the maximum number of tokens that can be bought in total for a given\\n/// address. The seller can also specify the price of erc1155 tokens and how\\n/// that price increases per successful transaction.\\ninterface IAirdropTokenSale {\\n\\n\\n    /// @notice the settings for the token sale,\\n    struct TokenSaleSettings {\\n\\n        // addresses\\n        address contractAddress; // the contract doing the selling\\n        address token; // the token being sold\\n        uint256 tokenHash; // the token hash being sold. set to 0 to autocreate hash\\n        uint256 collectionHash; // the collection hash being sold. set to 0 to autocreate hash\\n        // owner and payee\\n        address owner; // the owner of the contract\\n        address payee; // the payee of the contract\\n\\n        string symbol; // the symbol of the token\\n        string name; // the name of the token\\n        string description; // the description of the token\\n\\n        // open state\\n        bool openState; // open or closed\\n        uint256 startTime; // block number when the sale starts\\n        uint256 endTime; // block number when the sale ends\\n\\n        // quantities\\n        uint256 maxQuantity; // max number of tokens that can be sold\\n        uint256 maxQuantityPerSale; // max number of tokens that can be sold per sale\\n        uint256 minQuantityPerSale; // min number of tokens that can be sold per sale\\n        uint256 maxQuantityPerAccount; // max number of tokens that can be sold per account\\n\\n        // inital price of the token sale\\n        ITokenPrice.TokenPriceData initialPrice;\\n\\n    }\\n\\n    /// @notice emitted when a token is opened\\n    event TokenSaleOpen (uint256 tokenSaleId, TokenSaleSettings tokenSale );\\n\\n    /// @notice emitted when a token is opened\\n    event TokenSaleClosed (uint256 tokenSaleId, TokenSaleSettings tokenSale );\\n\\n    /// @notice emitted when a token is opened\\n    event TokenPurchased (uint256 tokenSaleId, address indexed purchaser, uint256 tokenId, uint256 quantity );\\n\\n    // token settings were updated\\n    event TokenSaleSettingsUpdated (uint256 tokenSaleId, TokenSaleSettings tokenSale );\\n\\n    /// @notice Get the token sale settings\\n    /// @return settings the token sale settings\\n    function getTokenSaleSettings(uint256 tokenSaleId) external view returns (TokenSaleSettings memory settings);\\n\\n    /// @notice Updates the token sale settings\\n    /// @param settings - the token sake settings\\n    function updateTokenSaleSettings(uint256 iTokenSaleId, TokenSaleSettings memory settings) external;\\n\\n    function initTokenSale(\\n        TokenSaleSettings memory tokenSaleInit,\\n        IAirdrop.AirdropSettings[] calldata settingsList\\n    ) external;\\n}\\n\",\"keccak256\":\"0xc7b749fa728930e1764305a5819b54131ae07461a436b46b19e2b01b54a61f20\",\"license\":\"Unlicense\"},\"contracts/interfaces/IClaim.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\n\\n/// @notice interface for a collection of tokens. lists members of collection, allows for querying of collection members, and for minting and burning of tokens.\\ninterface IClaim {\\n\\n\\n    /// @notice represents a claim on some deposit.\\n    struct Claim {\\n\\n        // claim id.\\n        uint256 id;\\n\\n        // pool id\\n        uint256 poolId;\\n\\n        // the creator of this claim\\n        address creator;\\n\\n        // the minter of this claim. This is the contract that minted the item, not the account that created the claim.\\n        address minter;\\n\\n        // the amount of eth deposited\\n        uint256 depositAmount;\\n\\n        // the type of deposit made. 0 for ETH or an ERC20 token\\n        address depositToken;\\n\\n        // the gem quantity to mint to the user upon maturity\\n        uint256 mintQuantity;\\n\\n        // the deposit length of time, in seconds\\n        uint256 depositLength;\\n\\n        // the block number when this record was created.\\n        uint256 createdTime;\\n\\n        // the block number when this record was created.\\n        uint256 createdBlock;\\n\\n        // block number when the claim was submitted or 0 if unclaimed\\n        uint256 claimedBlock;\\n\\n        // gem hash of minted gem(s) or 0 if no gem minted\\n        uint256 gemHash;\\n\\n        // the fee that was paid\\n        uint256 feePaid;\\n    }\\n\\n    /// @notice a set of requirements. used for random access\\n    struct ClaimSet {\\n\\n        mapping(uint256 => uint256) keyPointers;\\n        uint256[] keyList;\\n        Claim[] valueList;\\n\\n    }\\n\\n    struct ClaimSettings {\\n\\n        ClaimSet claims;\\n\\n        // the total staked for each token type (0 for ETH)\\n        mapping(address => uint256) stakedTotal;\\n\\n    }\\n\\n\\n    /// @notice emitted when a token is added to the collection\\n    event ClaimCreated(\\n        address indexed user,\\n        address indexed minter,\\n        Claim claim\\n    );\\n\\n    /// @notice emitted when a token is removed from the collection\\n    event ClaimRedeemed (\\n        address indexed user,\\n        address indexed minter,\\n        Claim claim\\n    );\\n\\n    /// @notice create a claim\\n    /// @param _claim the claim to create\\n    /// @return _claimHash the claim hash\\n    function createClaim(Claim memory _claim) external payable returns (Claim memory _claimHash);\\n\\n    /// @notice submit claim for collection\\n    /// @param claimHash the id of the claim\\n    function collectClaim(uint256 claimHash, bool requireMature) external;\\n\\n    /// @notice return the next claim hash\\n    /// @return _nextHash the next claim hash\\n    function nextClaimHash() external view returns (uint256 _nextHash);\\n\\n    /// @notice get all the claims\\n    /// @return _claims all the claims\\n    function claims() external view returns (Claim[] memory _claims);\\n\\n}\\n\",\"keccak256\":\"0xee865f68cf261f4005a2de2a84f936013a10cb1fb62ea35f004961225054eb55\",\"license\":\"Unlicense\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice a controllable contract interface. allows for controllers to perform privileged actions. controllera can other controllers and remove themselves.\\ninterface IControllable {\\n\\n    /// @notice emitted when a controller is added.\\n    event ControllerAdded(\\n        address indexed contractAddress,\\n        address indexed controllerAddress\\n    );\\n\\n    /// @notice emitted when a controller is removed.\\n    event ControllerRemoved(\\n        address indexed contractAddress,\\n        address indexed controllerAddress\\n    );\\n\\n    /// @notice adds a controller.\\n    /// @param controller the controller to add.\\n    function addController(address controller) external;\\n\\n    /// @notice removes a controller.\\n    /// @param controller the address to check\\n    /// @return true if the address is a controller\\n    function isController(address controller) external view returns (bool);\\n\\n    /// @notice remove ourselves from the list of controllers.\\n    function relinquishControl() external;\\n}\\n\",\"keccak256\":\"0x509861eda69d1c0e5e3087278dea73922d8708df9fccc41fecc8d1f4dd0b9818\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"contracts/interfaces/IERC1155Burn.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// implemented by erc1155 tokens to allow burning\\ninterface IERC1155Burn {\\n\\n    /// @notice event emitted when tokens are burned\\n    event Burned(\\n        address target,\\n        uint256 tokenHash,\\n        uint256 amount\\n    );\\n\\n    /// @notice burn tokens of specified amount from the specified address\\n    /// @param target the burn target\\n    /// @param tokenHash the token hash to burn\\n    /// @param amount the amount to burn\\n    function burn(\\n        address target,\\n        uint256 tokenHash,\\n        uint256 amount\\n    ) external;\\n\\n\\n}\\n\",\"keccak256\":\"0xb211cef77f9a160fe66b21fe10d657d7ef1ce8b9570322fd22e216a7c8ff1697\",\"license\":\"MIT\"},\"contracts/interfaces/IERC1155Mint.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// implemented by erc1155 tokens to allow mminting\\ninterface IERC1155Mint {\\n\\n    /// @notice event emitted when tokens are minted\\n    event Minted(\\n        address target,\\n        uint256 tokenHash,\\n        uint256 amount\\n    );\\n\\n    /// @notice mint tokens of specified amount to the specified address\\n    /// @param recipient the mint target\\n    /// @param tokenHash the token hash to mint\\n    /// @param amount the amount to mint\\n    function mint(\\n        address recipient,\\n        uint256 tokenHash,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function setMintAllowance(address receiver, uint256 tokenId, uint256 amount) external;\\n\\n}\\n\",\"keccak256\":\"0x6de8fa999edff67cba888fe013d8a7693c2aa7b74e6c7612a50199f02bed6d3d\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20Mint.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// implemented by erc1155 tokens to allow mminting\\ninterface IERC20Mint {\\n\\n    /// @notice event emitted when tokens are minted\\n    event Minted(\\n        address target,\\n        uint256 amount\\n    );\\n\\n    /// @notice mint tokens of specified amount to the specified address\\n    /// @param recipient the mint target\\n    /// @param amount the amount to mint\\n    function mint(\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function setMintAllowance(address receiver, uint256 tokenId, uint256 amount) external;\\n\\n}\\n\",\"keccak256\":\"0xe1b46631b8db87d0b628bfafe71356f3d82c96edc83c4372a3decb661990bf78\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721A.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721A {\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n    }\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct AddressData {\\n        // Realistically, 2**64-1 is more than enough.\\n        uint64 balance;\\n        // Keeps track of mint count with minimal overhead for tokenomics.\\n        uint64 numberMinted;\\n        // Keeps track of burn count with minimal overhead for tokenomics.\\n        uint64 numberBurned;\\n        // For miscellaneous variable(s) pertaining to the address\\n        // (e.g. number of whitelist mint slots used).\\n        // If there are multiple variables, please pack them into a uint64.\\n        uint64 aux;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8596388de3dbd302c9f0ddd89adb30b88bca9bef09494dfc2c11a8560612d88c\",\"license\":\"MIT\"},\"contracts/interfaces/IForge.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./ITokenDefinitions.sol\\\";\\nimport \\\"./IRequirement.sol\\\";\\n\\n// defines the forge. The forge contains items that can be minted in exchange for input items\\nstruct ForgeDefinition {\\n    // forge identifier\\n    uint256 forgeId;\\n    // forge symbol, name, description\\n    string name;\\n    string symbol;\\n    string description;\\n    // max number of forge operations\\n    uint256 maxForgeCount;\\n    // number of times this forge has been used\\n    uint256 forgedCount;\\n    // fee for each forge operation\\n    uint256 forgeFee;\\n}\\n\\n// defines a single requirement for a forge item\\nstruct ForgeItemRequirement {\\n    // the token address of the item\\n    address tokenAddress;\\n    // the token id of the item\\n    uint256 tokenId;\\n    // the amount of the item required\\n    uint256 amount;\\n}\\n\\n// defines each item that can be forged\\nstruct ForgeItemDefinition {\\n\\n    // item name, symbol, description\\n    string name;\\n    string symbol;\\n    string description;\\n\\n    // requirements for this item\\n    ForgeItemRequirement[] requirements;\\n\\n    // probability of this item being forged, if multiple items are possible, the probability is the sum of all probabilities\\n    uint256 probability;\\n    // number of times this item can be forged\\n    uint256 maxForgeCount;\\n    // number of times this item has been forged\\n    uint256 forgedCount;\\n    // fee to be paid for forging this item. overrides the forge fee of the forge if nonzero\\n    uint256 forgeFee;\\n    // token hash to mint for this item. if zero, then the token hash is autogenerated\\n    uint256 tokenHash;\\n}\\n\\n/// @notice a crafting matrix describes a set of items that can be crafted\\ninterface IForge {\\n\\n    /// @notice create a new forge\\n    /// @param name the name of the forge\\n    /// @param symbol the symbol of the forge\\n    /// @param description the description of the forge\\n    /// @param items the items that can be forged\\n    function createForge(string calldata name, string calldata symbol, string calldata description, ForgeItemDefinition[] calldata items) external;\\n\\n    /// @notice get the forge definition\\n    /// @param symbol the symbol of the forge\\n    function getForge(string calldata symbol) external view returns (ForgeDefinition memory);\\n\\n    // function _setForge(ForgeDefinition calldata forge) internal;\\n\\n    /// @notice get the list of forgeable items\\n    function forgeableItems() external view returns (ForgeItemDefinition[] memory);\\n\\n    /// @notice add a new forgeable item\\n    /// @param item the item to add\\n    /// @return the index of the item\\n    function addForgeableItem(ForgeItemDefinition calldata item) external returns (uint256);\\n\\n    /// @notice forge an item\\n    /// @param symbol the symbol of the forge\\n    /// @param inputItems the input items\\n    /// @return the forged item\\n    function forgeAnyItem(string calldata symbol, uint256[] calldata inputItems) external returns (ForgeItemDefinition memory);\\n\\n    /// @notice forge an item\\n    /// @param symbol the symbol of the forge\\n    /// @param index the index of the item to forge\\n    /// @param inputItems the input items\\n    /// @return the forged item\\n    function forgeItemAtIndex(string calldata symbol, uint256 index, uint256[] calldata inputItems) external returns (ForgeItemDefinition memory);\\n\\n    /// @notice get the hash of a forge\\n    /// @param symbol the symbol of the forge\\n    function getForgeHash(string calldata symbol) external view returns (uint256);\\n\\n    /// @notice get the forge by hash\\n    /// @param hash the hash of the forge\\n    function getForgeByHash(uint256 hash) external view returns (ForgeDefinition memory);\\n\\n    /// @notice ForgeCreated\\n    /// @param forge the forge that was created\\n    event ForgeCreated(ForgeDefinition forge);\\n\\n    /// @notice ForgeItemAdded\\n    /// @param item the item that was added\\n    event ForgeItemAdded(ForgeItemDefinition item);\\n\\n    /// @notice ItemForged\\n    /// @param receiver the receiver of the item\\n    /// @param item the item that was forged\\n    /// @param quantity the quantity of the item that was forged\\n    event ItemForged(address receiver, ForgeItemDefinition item, uint256 quantity);\\n\\n}\\n\",\"keccak256\":\"0x49319262c023a28bf4189ca8189c3a5ff9007c0970b20fcdc4a4f751ff2bd13e\",\"license\":\"MIT\"},\"contracts/interfaces/IGemPool.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"./IToken.sol\\\";\\nimport \\\"./ITokenPrice.sol\\\";\\n\\n/// @notice check the balance of earnings and collect earnings\\ninterface IGemPool {\\n\\n    /// @dev Event generated when a gem is created\\n    event GemPoolCreated(\\n\\n        // the gem pool account\\n        address creator,\\n\\n        // the gem pool account\\n        address contractAddress,\\n\\n        // the gem pool id\\n        uint256 pool,\\n\\n        // the gem token definition\\n        GemPoolSettings gemPoolDefinition\\n\\n    );\\n\\n    /// @dev Event generated when a gem is created\\n    event GemCreated(\\n\\n        // the gem pool account\\n        address account,\\n\\n        // the gem pool id\\n        uint256 pool,\\n\\n        // the gem hash\\n        uint256 gemHash,\\n\\n        // the gem token definition\\n        IToken.TokenDefinition tokenDefinition,\\n\\n        // the gem token quantity\\n        uint256 quantity\\n\\n    );\\n\\n    // mutable pool values\\n    struct GemPoolData {\\n\\n        // the gem pool id\\n        uint256 pool;\\n\\n        // nnext available gem hash\\n        uint256 nextGemHash;\\n\\n        // numbering for the next gem\\n        uint256 nextGemNumber;\\n\\n        // total number of gems minted\\n        uint256 gemsMintedCount;\\n\\n        // total amount of staked eth\\n        uint256 totalStakedEth;\\n\\n    }\\n\\n\\n    /// @notice staking pool settings - used to confignure a staking pool\\n    struct GemPoolSettings {\\n\\n        // the token address we mint on\\n        address token;\\n\\n        IToken.TokenSource tokenSource;\\n\\n        IToken.TokenDefinition tokenDefinition;\\n\\n        ITokenPrice.TokenPriceData initialPrice;\\n\\n        // is pool enabled\\n        bool enabled;\\n\\n        // is the pool visible\\n        bool visible;\\n\\n        // min and max token amounts to stake\\n        uint256 minTime;\\n\\n        // max time that the claim can be made\\n        uint256 maxTime;\\n\\n        // the difficulty step adjustment (or increase amount if PriceModifier is Static)\\n        uint256 diffstep;\\n\\n        // max total number of claims that can be made\\n        uint256 maxClaims;\\n\\n        // max quantity per claim\\n        uint256 maxQuantityPerClaim;\\n\\n        // max claims per account\\n        uint256 maxClaimsPerAccount;\\n\\n        // earn rate for this staking pool\\n        uint256 earnRatePerPeriod;\\n\\n        // the number of blocks per earning period\\n        uint256 earnPeriodBlocks;\\n\\n        // payout partial blocks\\n        bool payPartialBlocks;\\n\\n        // mint the earned token\\n        bool mintEarnedToken;\\n\\n        // max total earned amount per stake\\n        uint256 maxTotalEarnedAmount;\\n\\n        // allow outright purchases of gems\\n        bool allowPurchase;\\n\\n    }\\n\\n    struct GemPoolStruct {\\n\\n        GemPoolSettings _gemPoolSettings;\\n        GemPoolData _gemPoolData;\\n\\n    }\\n\\n    /// @notice get the hash of a gem pool\\n    function gemPoolHash(string memory symbol) external view returns (uint256 _gemPoolHash);\\n    /// @notice is token a member of the gem pool\\n    function isMemberOfPool(uint256 gemPoolId, uint256 token) external view returns (bool _isMember);\\n    /// @notice get the member gems of this pool\\n    function poolMembers(uint256 gemPoolId) external view returns (uint256[] memory _poolMembers);\\n    /// get the gem pool symbols in the contract\\n    function symbols() external view returns (string[] memory _symbols);\\n\\n}\\n\",\"keccak256\":\"0x89f3e7372c2970f97fb7775e663d081c9b3b58b6e998fcba9d44b40bf6a9e8be\",\"license\":\"Unlicense\"},\"contracts/interfaces/IMarketplace.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMarketplace {\\n    event Bids(uint256 indexed itemId, address bidder, uint256 amount);\\n    event Sales(uint256 indexed itemId, address indexed owner, uint256 amount, uint256 quantity, uint256 indexed tokenId);\\n    event Closes(uint256 indexed itemId);\\n    event Listings(\\n        uint256 indexed itemId,\\n        address indexed nftContract,\\n        uint256 indexed tokenId,\\n        address seller,\\n        address receiver,\\n        address owner,\\n        uint256 price,\\n        bool sold\\n    );\\n    struct MarketItem {\\n        uint256 itemId;\\n        address nftContract;\\n        uint256 tokenId;\\n        address seller;\\n        address owner;\\n        uint256 price;\\n        uint256 quantity;\\n        bool sold;\\n        address receiver;\\n    }\\n}\\n\",\"keccak256\":\"0x1717c9a03b80bb54b3befaf32002e99048ba53b82a50bb04d8cf14f67a97f10e\",\"license\":\"MIT\"},\"contracts/interfaces/IPower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IPower {\\n        event PowerUpdated (uint256 tokenId, uint256 power);\\n}\",\"keccak256\":\"0x95908940f3ee7cd3431422d091e720eb27ffc187a55f569038dc442228d78ad8\",\"license\":\"MIT\"},\"contracts/interfaces/IRequirement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IToken.sol\\\";\\nimport \\\"../utils/UInt256Set.sol\\\";\\n\\n/// @notice describes a list of requirements which will be checked against when someone performs an action\\ninterface IRequirement is IToken {\\n\\n    /// @notice an input requirement\\n    struct Requirement {\\n\\n        // the minter that this requirement aplpies to.\\n        address minter;\\n        // the token source to match for this requirement. Other a collection or a single token id\\n        TokenSource source;\\n        // the quantity of tokens to match for this requirement. must have at least this many tokens\\n        uint256 quantity;\\n        // whether or not to take custody of the tokens if the requirement is met\\n        bool takeCustody;\\n        // whether or not to burn the tokens if the requirement is met\\n        bool burn;\\n        // whether or not to require the exact amount of tokens to match for this requirement\\n        bool requireExactAmount;\\n\\n    }\\n\\n    // data for requirements\\n    struct RequirementData {\\n\\n        address token;\\n        address manager;\\n\\n        mapping(uint256 => Requirement[]) requirements;\\n        mapping(uint256 => TokenSet) tokens;\\n\\n        UInt256Set.Set burnedTokenIds;\\n        mapping(uint256 => uint256) burnedTokenQuantities;\\n\\n    }\\n\\n    struct RequirementSettings {\\n        RequirementData data;\\n    }\\n\\n    /// @notice get all requirements\\n    /// @return _reqs a set of requirements\\n    function requirements(uint256 collectionId) external view returns (Requirement[] memory _reqs);\\n\\n    /// @notice returns whether the specified account meets the requirement at the specified quantity factor\\n    /// @param account the minter to check\\n    /// @param req the requirement list to check\\n    /// @param quantity the quantity factor to check\\n    /// @return _tokens whether the account meets the requirements\\n    function fulfillingTokens(address account, Requirement memory req, uint256 quantity) external view returns (Token[] memory _tokens);\\n\\n    /// @notice returns whether the specified account meets the requirements at the specified quantity factor\\n    /// @param account the minter to check\\n    /// @param collectionId the requirement list to check\\n    /// @param quantity the quantity factor to check\\n    /// @return _meetsRequirements whether the account meets the requirements\\n    function meetsRequirements(address account, uint256 collectionId, uint256 quantity) external view returns (bool _meetsRequirements);\\n\\n    function custodyRequirements(\\n        uint256 transferId,\\n        address from,\\n        address token,\\n        Requirement[] memory reqs,\\n        uint256 quantity) external returns(Token[] memory _transferredTokens);\\n\\n    function releaseRequirements(\\n        uint256 transferId,\\n        address token,\\n        address to) external;\\n}\\n\",\"keccak256\":\"0xd1fe997ef5a5952a77c79d8f45c55a3b6c8cd3adfc278a5b9cc44f8c16d69b3e\",\"license\":\"MIT\"},\"contracts/interfaces/IToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n\\n/// @notice common struct definitions for tokens\\ninterface IToken {\\n\\n\\n    enum TokenType {\\n        ERC20,\\n        ERC721,\\n        ERC1155\\n    }\\n\\n    struct Token {\\n\\n        uint256 id;\\n        uint256 balance;\\n        bool burn;\\n\\n    }\\n\\n    /// @notice a set of tokens.\\n    struct TokenSet {\\n\\n        mapping(uint256 => uint256) keyPointers;\\n        uint256[] keyList;\\n        Token[] valueList;\\n\\n    }\\n\\n    /// @notice the definition for a token.\\n    struct TokenDefinition {\\n\\n        // the host multitoken\\n        address token;\\n\\n        // the id of the token definition. if static mint then also token hash\\n        uint256 id;\\n\\n        // the category name\\n        uint256 collectionId;\\n\\n        // the name of the token\\n        string name;\\n\\n        // the symbol of the token\\n        string symbol;\\n\\n        // the description of the token\\n        string description;\\n\\n        // the decimals of the token. 0 for NFT\\n        uint8 decimals;\\n\\n        // the total supply of the token\\n        uint256 totalSupply;\\n\\n        // whether to generate the id or not for new tokens. if false then we use id field of the definition to mint tokens\\n        bool generateId;\\n\\n        // probability of the item being awarded\\n        uint256 probability;\\n\\n         // the index of the probability in its array\\n        uint256 probabilityIndex;\\n\\n         // the index of the probability in its array\\n        uint256 probabilityRoll;\\n\\n    }\\n\\n    struct TokenRecord {\\n\\n        uint256 id;\\n        address owner;\\n        address minter;\\n        uint256 _type;\\n        uint256 balance;\\n\\n    }\\n\\n    /// @notice the token source type. Either a static source or a collection.\\n    enum TokenSourceType {\\n\\n        Static,\\n        Collection\\n\\n    }\\n\\n    /// @notice the token source. Specifies the source of the token - either a static source or a collection.\\n    struct TokenSource {\\n\\n        // the token source type\\n        TokenSourceType _type;\\n        // the source id if a static collection\\n        uint256 staticSourceId;\\n        // the collection source address if collection\\n        address collectionSourceAddress;\\n\\n    }\\n}\\n\",\"keccak256\":\"0x37288bbd845594ef413956da9bde6132a02eb88587b73c7254a1a926423bcab5\",\"license\":\"MIT\"},\"contracts/interfaces/ITokenDefinitions.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IToken.sol\\\";\\n\\n///\\n/// @notice a list of token definitions\\n///\\ninterface ITokenDefinitions {\\n\\n    struct TokenDefinitionsSettings {\\n\\n        IToken.TokenDefinition[] tokenDefinitions;\\n\\n    }\\n\\n    /// @notice emitted when a lootbox is created\\n    event TokenDefinitionsCreated(\\n        address indexed creator,\\n        address indexed contractAddress,\\n        IToken.TokenDefinition[] definitions\\n    );\\n\\n    /// @notice emitted when a lootbox is created\\n    event TokenDefinitionAdded(\\n        address indexed creator,\\n        address indexed contractAddress,\\n        IToken.TokenDefinition definitions\\n    );\\n\\n    /// @notice a set of tokens.\\n    struct TokenDefinitionSet {\\n\\n        mapping(uint256 => uint256) keyPointers;\\n        uint256[] keyList;\\n        IToken.TokenDefinition[] valueList;\\n\\n    }\\n\\n    function tokenDefinitions() external view returns (IToken.TokenDefinition[] memory);\\n    function makeHash(IToken.TokenDefinition memory _definition) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x2ecfc96bb7d8e059bb6a8ca79604904d95ff4c1d9409c134763b578479d6ddea\",\"license\":\"Unlicense\"},\"contracts/interfaces/ITokenMinter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IERC1155Burn.sol\\\";\\n\\n/**\\n * @notice This intreface provides a way for users to register addresses as permissioned minters, mint * burn, unregister, and reload the permissioned minter account.\\n */\\ninterface ITokenMinter {\\n\\n    /// @notice a registration record for a permissioned minter.\\n    struct Minter {\\n\\n        // the account address of the permissioned minter.\\n        address account;\\n        // the amount of tokens minted by the permissioned minter.\\n        uint256 minted;\\n        // the amount of tokens minted by the permissioned minter.\\n        uint256 burned;\\n        // the amount of payment spent by the permissioned minter.\\n        uint256 spent;\\n        // an approval map for this minter. sets a count of tokens the approved can mint.\\n        // mapping(address => uint256) approved; // TODO implement this.\\n\\n    }\\n\\n    /// @notice event emitted when minter is registered\\n    event MinterRegistered(\\n        address indexed registrant,\\n        uint256 depositPaid\\n    );\\n\\n    /// @notice emoitted when minter is unregistered\\n    event MinterUnregistered(\\n        address indexed registrant,\\n        uint256 depositReturned\\n    );\\n\\n    /// @notice emitted when minter address is reloaded\\n    event MinterReloaded(\\n        address indexed registrant,\\n        uint256 amountDeposited\\n    );\\n\\n    /// @notice get the registration record for a permissioned minter.\\n    /// @param _minter the address\\n    /// @return _minterObj the address\\n    function minter(address _minter) external returns (Minter memory _minterObj);\\n\\n    /// @notice mint a token associated with a collection with an amount\\n    /// @param receiver the mint receiver\\n    /// @param collectionId the collection id\\n    /// @param amount the amount to mint\\n    function mint(address receiver, uint256 collectionId, uint256 id, uint256 amount) external;\\n\\n    /// @notice mint a token associated with a collection with an amount\\n    /// @param target the mint receiver\\n    /// @param id the collection id\\n    /// @param amount the amount to mint\\n    function burn(address target, uint256 id, uint256 amount) external;\\n\\n}\\n\",\"keccak256\":\"0xeed55742206b89aa5b45f8872e2af6a05f6976ca44f6e9e89b24b2761880ec55\",\"license\":\"MIT\"},\"contracts/interfaces/ITokenPrice.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n\\n/// @notice common struct definitions for tokens\\ninterface ITokenPrice {\\n\\n    /// @notice DIctates how the price of the token is increased post every sale\\n    enum PriceModifier {\\n\\n        None,\\n        Fixed,\\n        Exponential,\\n        InverseLog\\n\\n    }\\n\\n    /// @notice a token price and how it changes\\n    struct TokenPriceData {\\n\\n        // the price of the token\\n        uint256 price;\\n         // how the price is modified\\n        PriceModifier priceModifier;\\n        // only used if priceModifier is EXPONENTIAL or INVERSELOG or FIXED\\n        uint256 priceModifierFactor;\\n        // max price for the token\\n        uint256 maxPrice;\\n\\n    }\\n\\n    /// @notice get the increased price of the token\\n    function getIncreasedPrice() external view returns (uint256);\\n\\n    /// @notice get the increased price of the token\\n    function getTokenPrice() external view returns (TokenPriceData memory);\\n\\n\\n}\\n\",\"keccak256\":\"0xf02fd48efda614a43b09abf069628e12498052cd256ce5ea7fcfc56329ea09a8\",\"license\":\"MIT\"},\"contracts/interfaces/ITokenSale.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\n///\\n/// @notice A token seller is a contract that can sell tokens to a token buyer.\\n/// The token buyer can buy tokens from the seller by paying a certain amount\\n/// of base currency to receive a certain amount of erc1155 tokens. the number\\n/// of tokens that can be bought is limited by the seller - the seller can\\n/// specify the maximum number of tokens that can be bought per transaction\\n/// and the maximum number of tokens that can be bought in total for a given\\n/// address. The seller can also specify the price of erc1155 tokens and how\\n/// that price increases per successful transaction.\\ninterface ITokenSale {\\n\\n    struct TokenSaleEntry {\\n        address payable receiver;\\n        address sourceToken;\\n        uint256 sourceTokenId;\\n        address token;\\n        uint256 quantity;\\n        uint256 price;\\n        uint256 quantitySold;\\n    }\\n\\n    event TokenSaleSet(address indexed token, uint256 indexed tokenId, uint256 price, uint256 quantity);\\n    event TokenSold(address indexed buyer, address indexed tokenAddress, uint256 indexed tokenId, uint256 salePrice);\\n    event TokensSet(address indexed tokenAddress, ITokenSale.TokenSaleEntry tokens);\\n\\n}\\n\",\"keccak256\":\"0xd2979d88618abb234e4f1391ebf6ba858602234682959b36c0621d2364f56f11\",\"license\":\"Unlicense\"},\"contracts/utils/AddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @notice Key sets with enumeration and delete. Uses mappings for random\\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\\n * fixed gas cost at any scale, O(1).\\n * author: Rob Hitchens\\n */\\n\\nlibrary AddressSet {\\n    struct Set {\\n        mapping(address => uint256) keyPointers;\\n        address[] keyList;\\n    }\\n\\n    /**\\n     * @notice insert a key.\\n     * @dev duplicate keys are not permitted.\\n     * @param self storage pointer to a Set.\\n     * @param key value to insert.\\n     */\\n    function insert(Set storage self, address key) public {\\n        require(\\n            !exists(self, key),\\n            \\\"AddressSet: key already exists in the set.\\\"\\n        );\\n        self.keyList.push(key);\\n        self.keyPointers[key] = self.keyList.length - 1;\\n    }\\n\\n    /**\\n     * @notice remove a key.\\n     * @dev key to remove must exist.\\n     * @param self storage pointer to a Set.\\n     * @param key value to remove.\\n     */\\n    function remove(Set storage self, address key) public {\\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\\n        require(\\n            exists(self, key),\\n            \\\"AddressSet: key does not exist in the set.\\\"\\n        );\\n        if (!exists(self, key)) return;\\n        uint256 last = count(self) - 1;\\n        uint256 rowToReplace = self.keyPointers[key];\\n        if (rowToReplace != last) {\\n            address keyToMove = self.keyList[last];\\n            self.keyPointers[keyToMove] = rowToReplace;\\n            self.keyList[rowToReplace] = keyToMove;\\n        }\\n        delete self.keyPointers[key];\\n        self.keyList.pop();\\n    }\\n\\n    /**\\n     * @notice count the keys.\\n     * @param self storage pointer to a Set.\\n     */\\n    function count(Set storage self) public view returns (uint256) {\\n        return (self.keyList.length);\\n    }\\n\\n    /**\\n     * @notice check if a key is in the Set.\\n     * @param self storage pointer to a Set.\\n     * @param key value to check.\\n     * @return bool true: Set member, false: not a Set member.\\n     */\\n    function exists(Set storage self, address key)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        if (self.keyList.length == 0) return false;\\n        return self.keyList[self.keyPointers[key]] == key;\\n    }\\n\\n    /**\\n     * @notice fetch a key by row (enumerate).\\n     * @param self storage pointer to a Set.\\n     * @param index row to enumerate. Must be < count() - 1.\\n     */\\n    function keyAtIndex(Set storage self, uint256 index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return self.keyList[index];\\n    }\\n}\\n\",\"keccak256\":\"0x3b999937288120e5f0651a80c259e5016f7ed9db37ec78aafb0da8b9d70bcae7\",\"license\":\"MIT\"},\"contracts/utils/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nlibrary MerkleProof {\\n\\n  function verify(\\n    bytes32 root,\\n    bytes32 leaf,\\n    bytes32[] memory proof\\n  )\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    bytes32 computedHash = leaf;\\n\\n    for (uint256 i = 0; i < proof.length; i++) {\\n      bytes32 proofElement = proof[i];\\n\\n      if (computedHash <= proofElement) {\\n        // Hash(current computed hash + current element of the proof)\\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n      } else {\\n        // Hash(current element of the proof + current computed hash)\\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n      }\\n    }\\n\\n    // Check if the computed hash (root) is equal to the provided root\\n    return computedHash == root;\\n  }\\n\\n  function getHash(address a, uint256 b) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(a, b));\\n  }\\n\\n}\\n\",\"keccak256\":\"0xff1263d1cb07a5013ee685cd9a0f4c00c02c74671c78162a392fe6666b342b5d\",\"license\":\"MIT\"},\"contracts/utils/UInt256Set.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @notice Key sets with enumeration and delete. Uses mappings for random\\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\\n * fixed gas cost at any scale, O(1).\\n * author: Rob Hitchens\\n */\\n\\nlibrary UInt256Set {\\n    struct Set {\\n        mapping(uint256 => uint256) keyPointers;\\n        uint256[] keyList;\\n    }\\n\\n    /**\\n     * @notice insert a key.\\n     * @dev duplicate keys are not permitted.\\n     * @param self storage pointer to a Set.\\n     * @param key value to insert.\\n     */\\n    function insert(Set storage self, uint256 key) public {\\n        require(\\n            !exists(self, key),\\n            \\\"UInt256Set: key already exists in the set.\\\"\\n        );\\n        self.keyList.push(key);\\n        self.keyPointers[key] = self.keyList.length - 1;\\n    }\\n\\n    /**\\n     * @notice remove a key.\\n     * @dev key to remove must exist.\\n     * @param self storage pointer to a Set.\\n     * @param key value to remove.\\n     */\\n    function remove(Set storage self, uint256 key) public {\\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\\n        // require(\\n        //     exists(self, key),\\n        //     \\\"UInt256Set: key does not exist in the set.\\\"\\n        // );\\n        if (!exists(self, key)) return;\\n        uint256 last = count(self) - 1;\\n        uint256 rowToReplace = self.keyPointers[key];\\n        if (rowToReplace != last) {\\n            uint256 keyToMove = self.keyList[last];\\n            self.keyPointers[keyToMove] = rowToReplace;\\n            self.keyList[rowToReplace] = keyToMove;\\n        }\\n        delete self.keyPointers[key];\\n        delete self.keyList[self.keyList.length - 1];\\n    }\\n\\n    /**\\n     * @notice count the keys.\\n     * @param self storage pointer to a Set.\\n     */\\n    function count(Set storage self) public view returns (uint256) {\\n        return (self.keyList.length);\\n    }\\n\\n    /**\\n     * @notice check if a key is in the Set.\\n     * @param self storage pointer to a Set.\\n     * @param key value to check.\\n     * @return bool true: Set member, false: not a Set member.\\n     */\\n    function exists(Set storage self, uint256 key)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        if (self.keyList.length == 0) return false;\\n        return self.keyList[self.keyPointers[key]] == key;\\n    }\\n\\n    /**\\n     * @notice fetch a key by row (enumerate).\\n     * @param self storage pointer to a Set.\\n     * @param index row to enumerate. Must be < count() - 1.\\n     */\\n    function keyAtIndex(Set storage self, uint256 index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return self.keyList[index];\\n    }\\n}\\n\",\"keccak256\":\"0x31d27b2c71ad5bb53daf91e37e2b56fc89341f0d2015a87efd609e12b93d32c8\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612174806100206000396000f3fe6080604052600436106100605760003560e01c806365ae58b6146100655780639d763be014610098578063da8dadef146100ba578063e95ede06146100cd578063f31934cf146100fa578063f58be6f31461011a578063fef48a511461013a575b600080fd5b34801561007157600080fd5b506100856100803660046117ed565b61014d565b6040519081526020015b60405180910390f35b3480156100a457600080fd5b506100b86100b3366004611963565b610428565b005b6100b86100c83660046118a0565b6104a4565b3480156100d957600080fd5b506100ed6100e8366004611887565b6104bd565b60405161008f9190611f69565b34801561010657600080fd5b506100b8610115366004611742565b6107e6565b34801561012657600080fd5b506100b861013536600461191d565b610877565b6100b86101483660046119a0565b610af6565b60208301516000906001600160a01b03166101af5760405162461bcd60e51b815260206004820152601e60248201527f4d756c7469746f6b656e2061646472657373206d75737420626520736574000060448201526064015b60405180910390fd5b811561020d5760405163671b250f60e01b8152309063671b250f906101da9086908690600401611c5c565b600060405180830381600087803b1580156101f457600080fd5b505af1158015610208573d6000803e3d6000fd5b505050505b6028546040805160208101929092526001600160601b03193060601b169082015260540160408051808303601f1901815291815281516020928301206000818152602a8452829020875181546001600160a01b03199081166001600160a01b03928316178355898601516001840180548316918416919091179055938901516002830155606089015160038301556080890151600483018054861691831691909117905560a089015160058301805490951691161790925560c0870151805191945087936102e3926006850192909101906112c9565b5060e082015180516102ff9160078401916020909101906112c9565b50610100820151805161031c9160088401916020909101906112c9565b5061012082015160098201805491151560ff19928316179055610140830151600a830155610160830151600b830155610180830151600c8301556101a0830151600d8301556101c0830151600e8301556101e0830151600f830155610200830151805160108401908155602082015160118501805493949293919290911660018360038111156103ae576103ae612101565b021790555060408281015160028301556060909201516003909101556000848152602a60205281902080546001600160a01b03191630179055518392507fb75bc04b48e14e4f6d27b395800bfd2af3090c942e28456088012146d20c8a399150610419908790611f69565b60405180910390a29392505050565b6000848152602a6020526040908190206001015490516340c10f1960e01b81526001600160a01b03848116600483015260248201849052909116906340c10f1990604401600060405180830381600087803b15801561048657600080fd5b505af115801561049a573d6000803e3d6000fd5b5050505050505050565b6104b48787878787878734610b02565b50505050505050565b6104c561134d565b60408051610220810182526000848152602a602081815284832080546001600160a01b039081168652600182015481168387015260028201549686019690965260038101546060860152600481015486166080860152600581015490951660a08501529186905290526006909101805460c08301919061054490612095565b80601f016020809104026020016040519081016040528092919081815260200182805461057090612095565b80156105bd5780601f10610592576101008083540402835291602001916105bd565b820191906000526020600020905b8154815290600101906020018083116105a057829003601f168201915b505050505081526020016000602801600201600085815260200190815260200160002060070180546105ee90612095565b80601f016020809104026020016040519081016040528092919081815260200182805461061a90612095565b80156106675780601f1061063c57610100808354040283529160200191610667565b820191906000526020600020905b81548152906001019060200180831161064a57829003601f168201915b5050505050815260200160006028016002016000858152602001908152602001600020600801805461069890612095565b80601f01602080910402602001604051908101604052809291908181526020018280546106c490612095565b80156107115780601f106106e657610100808354040283529160200191610711565b820191906000526020600020905b8154815290600101906020018083116106f457829003601f168201915b50505091835250506000848152602a60208181526040808420600981015460ff908116151584880152600a82015483880152600b8201546060880152600c820154608080890191909152600d83015460a0890152600e83015460c0890152600f83015460e0890152958a905293835281519485019091526010810180548552601190910154610100909501949092918401911660038111156107b5576107b5612101565b60038111156107c6576107c6612101565b815260028201546020820152600390910154604090910152905292915050565b336107ef61108c565b6001600160a01b0316148061080357503033145b61081f5760405162461bcd60e51b81526004016101a690611e56565b6040516343654f3d60e11b815230906386ca9e7a90610842908490600401611ed9565b600060405180830381600087803b15801561085c57600080fd5b505af1158015610870573d6000803e3d6000fd5b5050505050565b3361088061108c565b6001600160a01b0316148061089457503033145b6108b05760405162461bcd60e51b81526004016101a690611e56565b6000828152602a60205260409020600401546001600160a01b031633146109335760405162461bcd60e51b815260206004820152603160248201527f4f6e6c7920746865206f776e65722063616e207570646174652074686520746f6044820152706b656e2073616c652073657474696e677360781b60648201526084016101a6565b6000828152602a6020908152604091829020835181546001600160a01b03199081166001600160a01b03928316178355858401516001840180548316918416919091179055938501516002830155606085015160038301556080850151600483018054861691831691909117905560a085015160058301805490951691161790925560c083015180518493926109d09260068501929101906112c9565b5060e082015180516109ec9160078401916020909101906112c9565b506101008201518051610a099160088401916020909101906112c9565b5061012082015160098201805491151560ff19928316179055610140830151600a830155610160830151600b830155610180830151600c8301556101a0830151600d8301556101c0830151600e8301556101e0830151600f83015561020083015180516010840190815560208201516011850180549394929391929091166001836003811115610a9b57610a9b612101565b0217905550604082015181600201556060820151816003015550509050507f243f6103dcdeac8ced1c019ee514b95aefe88bc49ed1d95f455cb8a668a9cc628282604051610aea929190611f7c565b60405180910390a15050565b6104b4878585858a8a87345b8315610e6757600084815260136020526040902060018101548514610b395760405162461bcd60e51b81526004016101a690611d22565b60405163434705f160e11b8152600481018690526001600160a01b0389166024820152309063868e0be29060440160206040518083038186803b158015610b7f57600080fd5b505afa158015610b93573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb7919061171e565b15610bff5760405162461bcd60e51b8152602060048201526018602482015277105a5c991c9bdc08185b1c9958591e481c995919595b595960421b60448201526064016101a6565b60038101541580610c315750600381015415801590610c3157508060030154878260070154610c2e919061205e565b11155b610c4d5760405162461bcd60e51b81526004016101a690611d50565b600a8101548290610c5f908990612076565b1115610ca95760405162461bcd60e51b8152602060048201526019602482015278139bdd08195b9bdd59da081c1c9a58d948185d1d1858da1959603a1b60448201526064016101a6565b60058101541580610ccc5750600581015415801590610ccc575080600501548710155b610ce85760405162461bcd60e51b81526004016101a690611ddf565b60048101541580610d0b5750600481015415801590610d0b575080600401548711155b610d275760405162461bcd60e51b81526004016101a690611d9d565b806008015442101580610d3c57506008810154155b610d585760405162461bcd60e51b81526004016101a690611e20565b806009015442111580610d6d57506009810154155b610d895760405162461bcd60e51b81526004016101a690611ead565b805460ff1615610df35760405163378e98bb60e01b8152309063378e98bb90610dc090889088908d908d908d908b90600401611f9d565b600060405180830381600087803b158015610dda57600080fd5b505af1158015610dee573d6000803e3d6000fd5b505050505b60005b87811015610e6057610e098a878b6110ba565b50886001600160a01b0316867fcab378d19b1950615aa3acf93c1d36654ad5200ab340d952bde8072bfec95d19868b604051610e46929190611c3a565b60405180910390a380610e58816120d0565b915050610df6565b505061049a565b6000888152602a60205260409020600c01541580610eda57506000888152602a60205260409020600c015415801590610eda57506000888152602a602090815260408220600c0154918052602d90527f6648a85983aca0407b603b260cacb25b5e5e8e5194522de3d8a800e71aa41bae54105b610ef65760405162461bcd60e51b81526004016101a690611d50565b6000888152602a60205260409020600e01541580610f4057506000888152602a60205260409020600e015415801590610f4057506000888152602a60205260409020600e01548610155b610f5c5760405162461bcd60e51b81526004016101a690611ddf565b6000888152602a60205260409020600d01541580610fa657506000888152602a60205260409020600d015415801590610fa657506000888152602a60205260409020600d01548611155b610fc25760405162461bcd60e51b81526004016101a690611d9d565b6000888152602a60205260409020600a015442101580610ff157506000888152602a60205260409020600a0154155b61100d5760405162461bcd60e51b81526004016101a690611e20565b6000888152602a60205260409020600b01544211158061103c57506000888152602a60205260409020600b0154155b6110585760405162461bcd60e51b81526004016101a690611ead565b60005b868110156110815761106e89868a6110ba565b5080611079816120d0565b91505061105b565b505050505050505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320546001600160a01b031690565b600080831561110b5760008481526013602052604090206001015484146110f35760405162461bcd60e51b81526004016101a690611d22565b506000838152601360205260409020600e015461111f565b506000848152602a60205260409020600201545b806111a95760008581526029602052604090205461113e90600161205e565b60008681526029602090815260409182902083905581516f61697264726f70546f6b656e53616c6560801b81830152606087901b6001600160601b03191660308201526044810189905260648082019490945282518082039094018452608401909152815191012090505b6040516304ebb1df60e51b815260048101869052602481018590526001600160a01b0384166044820152600160648201523090639d763be090608401600060405180830381600087803b1580156111ff57600080fd5b505af1158015611213573d6000803e3d6000fd5b5050506000858152602d6020526040812080546001935090919061123890849061205e565b90915550506000848152602c602090815260408083206001600160a01b0387168452909152812080546001929061127090849061205e565b9091555050604080518681526020810183905260018183015290516001600160a01b038516917f9724b007b03edd022b805a7acc9bbc33ce21a84b5c9e360a5f71b367b97db86d919081900360600190a2949350505050565b8280546112d590612095565b90600052602060002090601f0160209004810192826112f7576000855561133d565b82601f1061131057805160ff191683800117855561133d565b8280016001018555821561133d579182015b8281111561133d578251825591602001919060010190611322565b50611349929150611420565b5090565b60405180610220016040528060006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160006001600160a01b0316815260200160006001600160a01b0316815260200160608152602001606081526020016060815260200160001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200161141b604080516080810190915260008082526020820190815260200160008152602001600081525090565b905290565b5b808211156113495760008155600101611421565b80356001600160a01b038116811461144c57600080fd5b919050565b600082601f83011261146257600080fd5b813560206001600160401b0382111561147d5761147d612117565b8160051b61148c82820161202e565b8381528281019086840183880185018910156114a757600080fd5b600093505b858410156114ca5780358352600193909301929184019184016114ac565b50979650505050505050565b803561144c8161212d565b80356004811061144c57600080fd5b600082601f83011261150157600080fd5b81356001600160401b0381111561151a5761151a612117565b61152d601f8201601f191660200161202e565b81815284602083860101111561154257600080fd5b816020850160208301376000918101602001919091529392505050565b60006080828403121561157157600080fd5b604051608081016001600160401b038111828210171561159357611593612117565b604052823581529050806115a9602084016114e1565b602082015260408301356040820152606083013560608201525092915050565b600061028082840312156115dc57600080fd5b6115e4611fe2565b90506115ef82611435565b81526115fd60208301611435565b6020820152604082013560408201526060820135606082015261162260808301611435565b608082015261163360a08301611435565b60a082015260c08201356001600160401b038082111561165257600080fd5b61165e858386016114f0565b60c084015260e084013591508082111561167757600080fd5b611683858386016114f0565b60e08401526101009150818401358181111561169e57600080fd5b6116aa868287016114f0565b838501525050506101206116bf8184016114d6565b908201526101408281013590820152610160808301359082015261018080830135908201526101a080830135908201526101c080830135908201526101e080830135908201526102006117148482850161155f565b9082015292915050565b60006020828403121561173057600080fd5b815161173b8161212d565b9392505050565b60006101e0828403121561175557600080fd5b61175d61200b565b611766836114d6565b81526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013581830152506101406117d58582860161155f565b908201526101c0929092013561016083015250919050565b60008060006040848603121561180257600080fd5b83356001600160401b038082111561181957600080fd5b611825878388016115c9565b9450602086013591508082111561183b57600080fd5b818601915086601f83011261184f57600080fd5b81358181111561185e57600080fd5b8760206101e08302850101111561187457600080fd5b6020830194508093505050509250925092565b60006020828403121561189957600080fd5b5035919050565b600080600080600080600060e0888a0312156118bb57600080fd5b873596506118cb60208901611435565b955060408801359450606088013593506080880135925060a0880135915060c08801356001600160401b0381111561190257600080fd5b61190e8a828b01611451565b91505092959891949750929550565b6000806040838503121561193057600080fd5b8235915060208301356001600160401b0381111561194d57600080fd5b611959858286016115c9565b9150509250929050565b6000806000806080858703121561197957600080fd5b843593506020850135925061199060408601611435565b9396929550929360600135925050565b600080600080600080600060e0888a0312156119bb57600080fd5b8735965060208801359550604088013594506119d960608901611435565b93506080880135925060a0880135915060c08801356001600160401b0381111561190257600080fd5b6001600160a01b03169052565b600081518084526020808501945080840160005b83811015611a3f57815187529582019590820190600101611a23565b509495945050505050565b60048110611a6857634e487b7160e01b600052602160045260246000fd5b9052565b6000815180845260005b81811015611a9257602081850181015186830182015201611a76565b81811115611aa4576000602083870101525b50601f01601f19169290920160200192915050565b80358252611ac9602082016114e1565b611ad66020840182611a4a565b5060408181013590830152606090810135910152565b805182526020810151611b026020840182611a4a565b5060408181015190830152606090810151910152565b6000610280611b28848451611a02565b6020830151611b3a6020860182611a02565b5060408301516040850152606083015160608501526080830151611b616080860182611a02565b5060a0830151611b7460a0860182611a02565b5060c08301518160c0860152611b8c82860182611a6c565b91505060e083015184820360e0860152611ba68282611a6c565b9150506101008084015185830382870152611bc18382611a6c565b9250505061012080840151611bd98287018215159052565b50506101408381015190850152610160808401519085015261018080840151908501526101a080840151908501526101c080840151908501526101e0808401519085015261020080840151611c3082870182611aec565b5090949350505050565b604081526000611c4d6040830185611a0f565b90508260208301529392505050565b6020808252818101839052600090604080840186845b87811015611d1557611c8d83611c87846114d6565b15159052565b81850135838601528382013584840152606080830135908401526080808301359084015260a0808301359084015260c0808301359084015260e0808301359084015261010080830135908401526101208083013590840152610140611cf6818501828501611ab9565b506101c082810135908401526101e09283019290910190600101611c72565b5090979650505050505050565b602080825260149082015273105a5c991c9bdc08191bd95cdb9d08195e1a5cdd60621b604082015260600190565b6020808252602d908201527f546865206d6178696d756d20616d6f756e74206f6620746f6b656e732068617360408201526c103132b2b7103137bab3b43a1760991b606082015260800190565b60208082526022908201527f4d6178696d756d207175616e74697479207065722073616c6520657863656564604082015261195960f21b606082015260800190565b60208082526021908201527f4d696e696d756d207175616e74697479207065722073616c65206e6f74206d656040820152601d60fa1b606082015260800190565b6020808252601c908201527b151a19481cd85b19481a185cc81b9bdd081cdd185c9d1959081e595d60221b604082015260600190565b60208082526037908201527f455243313135353a206f6e6c792074686520636f6e7472616374206f776e65726040820152761031b0b71031b0b636103a3434b990333ab731ba34b7b760491b606082015260800190565b602080825260129082015271151a19481cd85b19481a185cc8195b99195960721b604082015260600190565b8151151581526101e081016020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151818401525061012080840151818401525061014080840151611f5582850182611aec565b50506101608301516101c083015292915050565b60208152600061173b6020830184611b18565b828152604060208201526000611f956040830184611b18565b949350505050565b86815285602082015260018060a01b038516604082015283606082015282608082015260c060a08201526000611fd660c0830184611a0f565b98975050505050505050565b60405161022081016001600160401b038111828210171561200557612005612117565b60405290565b60405161018081016001600160401b038111828210171561200557612005612117565b604051601f8201601f191681016001600160401b038111828210171561205657612056612117565b604052919050565b60008219821115612071576120716120eb565b500190565b6000816000190483118215151615612090576120906120eb565b500290565b600181811c908216806120a957607f821691505b602082108114156120ca57634e487b7160e01b600052602260045260246000fd5b50919050565b60006000198214156120e4576120e46120eb565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b801515811461213b57600080fd5b5056fea264697066735822122064e22bee4a430ae7c0e4cf20583f568b14cb2a175934b8c0191b183ebfb9a36c64736f6c63430008060033",
  "deployedBytecode": "0x6080604052600436106100605760003560e01c806365ae58b6146100655780639d763be014610098578063da8dadef146100ba578063e95ede06146100cd578063f31934cf146100fa578063f58be6f31461011a578063fef48a511461013a575b600080fd5b34801561007157600080fd5b506100856100803660046117ed565b61014d565b6040519081526020015b60405180910390f35b3480156100a457600080fd5b506100b86100b3366004611963565b610428565b005b6100b86100c83660046118a0565b6104a4565b3480156100d957600080fd5b506100ed6100e8366004611887565b6104bd565b60405161008f9190611f69565b34801561010657600080fd5b506100b8610115366004611742565b6107e6565b34801561012657600080fd5b506100b861013536600461191d565b610877565b6100b86101483660046119a0565b610af6565b60208301516000906001600160a01b03166101af5760405162461bcd60e51b815260206004820152601e60248201527f4d756c7469746f6b656e2061646472657373206d75737420626520736574000060448201526064015b60405180910390fd5b811561020d5760405163671b250f60e01b8152309063671b250f906101da9086908690600401611c5c565b600060405180830381600087803b1580156101f457600080fd5b505af1158015610208573d6000803e3d6000fd5b505050505b6028546040805160208101929092526001600160601b03193060601b169082015260540160408051808303601f1901815291815281516020928301206000818152602a8452829020875181546001600160a01b03199081166001600160a01b03928316178355898601516001840180548316918416919091179055938901516002830155606089015160038301556080890151600483018054861691831691909117905560a089015160058301805490951691161790925560c0870151805191945087936102e3926006850192909101906112c9565b5060e082015180516102ff9160078401916020909101906112c9565b50610100820151805161031c9160088401916020909101906112c9565b5061012082015160098201805491151560ff19928316179055610140830151600a830155610160830151600b830155610180830151600c8301556101a0830151600d8301556101c0830151600e8301556101e0830151600f830155610200830151805160108401908155602082015160118501805493949293919290911660018360038111156103ae576103ae612101565b021790555060408281015160028301556060909201516003909101556000848152602a60205281902080546001600160a01b03191630179055518392507fb75bc04b48e14e4f6d27b395800bfd2af3090c942e28456088012146d20c8a399150610419908790611f69565b60405180910390a29392505050565b6000848152602a6020526040908190206001015490516340c10f1960e01b81526001600160a01b03848116600483015260248201849052909116906340c10f1990604401600060405180830381600087803b15801561048657600080fd5b505af115801561049a573d6000803e3d6000fd5b5050505050505050565b6104b48787878787878734610b02565b50505050505050565b6104c561134d565b60408051610220810182526000848152602a602081815284832080546001600160a01b039081168652600182015481168387015260028201549686019690965260038101546060860152600481015486166080860152600581015490951660a08501529186905290526006909101805460c08301919061054490612095565b80601f016020809104026020016040519081016040528092919081815260200182805461057090612095565b80156105bd5780601f10610592576101008083540402835291602001916105bd565b820191906000526020600020905b8154815290600101906020018083116105a057829003601f168201915b505050505081526020016000602801600201600085815260200190815260200160002060070180546105ee90612095565b80601f016020809104026020016040519081016040528092919081815260200182805461061a90612095565b80156106675780601f1061063c57610100808354040283529160200191610667565b820191906000526020600020905b81548152906001019060200180831161064a57829003601f168201915b5050505050815260200160006028016002016000858152602001908152602001600020600801805461069890612095565b80601f01602080910402602001604051908101604052809291908181526020018280546106c490612095565b80156107115780601f106106e657610100808354040283529160200191610711565b820191906000526020600020905b8154815290600101906020018083116106f457829003601f168201915b50505091835250506000848152602a60208181526040808420600981015460ff908116151584880152600a82015483880152600b8201546060880152600c820154608080890191909152600d83015460a0890152600e83015460c0890152600f83015460e0890152958a905293835281519485019091526010810180548552601190910154610100909501949092918401911660038111156107b5576107b5612101565b60038111156107c6576107c6612101565b815260028201546020820152600390910154604090910152905292915050565b336107ef61108c565b6001600160a01b0316148061080357503033145b61081f5760405162461bcd60e51b81526004016101a690611e56565b6040516343654f3d60e11b815230906386ca9e7a90610842908490600401611ed9565b600060405180830381600087803b15801561085c57600080fd5b505af1158015610870573d6000803e3d6000fd5b5050505050565b3361088061108c565b6001600160a01b0316148061089457503033145b6108b05760405162461bcd60e51b81526004016101a690611e56565b6000828152602a60205260409020600401546001600160a01b031633146109335760405162461bcd60e51b815260206004820152603160248201527f4f6e6c7920746865206f776e65722063616e207570646174652074686520746f6044820152706b656e2073616c652073657474696e677360781b60648201526084016101a6565b6000828152602a6020908152604091829020835181546001600160a01b03199081166001600160a01b03928316178355858401516001840180548316918416919091179055938501516002830155606085015160038301556080850151600483018054861691831691909117905560a085015160058301805490951691161790925560c083015180518493926109d09260068501929101906112c9565b5060e082015180516109ec9160078401916020909101906112c9565b506101008201518051610a099160088401916020909101906112c9565b5061012082015160098201805491151560ff19928316179055610140830151600a830155610160830151600b830155610180830151600c8301556101a0830151600d8301556101c0830151600e8301556101e0830151600f83015561020083015180516010840190815560208201516011850180549394929391929091166001836003811115610a9b57610a9b612101565b0217905550604082015181600201556060820151816003015550509050507f243f6103dcdeac8ced1c019ee514b95aefe88bc49ed1d95f455cb8a668a9cc628282604051610aea929190611f7c565b60405180910390a15050565b6104b4878585858a8a87345b8315610e6757600084815260136020526040902060018101548514610b395760405162461bcd60e51b81526004016101a690611d22565b60405163434705f160e11b8152600481018690526001600160a01b0389166024820152309063868e0be29060440160206040518083038186803b158015610b7f57600080fd5b505afa158015610b93573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb7919061171e565b15610bff5760405162461bcd60e51b8152602060048201526018602482015277105a5c991c9bdc08185b1c9958591e481c995919595b595960421b60448201526064016101a6565b60038101541580610c315750600381015415801590610c3157508060030154878260070154610c2e919061205e565b11155b610c4d5760405162461bcd60e51b81526004016101a690611d50565b600a8101548290610c5f908990612076565b1115610ca95760405162461bcd60e51b8152602060048201526019602482015278139bdd08195b9bdd59da081c1c9a58d948185d1d1858da1959603a1b60448201526064016101a6565b60058101541580610ccc5750600581015415801590610ccc575080600501548710155b610ce85760405162461bcd60e51b81526004016101a690611ddf565b60048101541580610d0b5750600481015415801590610d0b575080600401548711155b610d275760405162461bcd60e51b81526004016101a690611d9d565b806008015442101580610d3c57506008810154155b610d585760405162461bcd60e51b81526004016101a690611e20565b806009015442111580610d6d57506009810154155b610d895760405162461bcd60e51b81526004016101a690611ead565b805460ff1615610df35760405163378e98bb60e01b8152309063378e98bb90610dc090889088908d908d908d908b90600401611f9d565b600060405180830381600087803b158015610dda57600080fd5b505af1158015610dee573d6000803e3d6000fd5b505050505b60005b87811015610e6057610e098a878b6110ba565b50886001600160a01b0316867fcab378d19b1950615aa3acf93c1d36654ad5200ab340d952bde8072bfec95d19868b604051610e46929190611c3a565b60405180910390a380610e58816120d0565b915050610df6565b505061049a565b6000888152602a60205260409020600c01541580610eda57506000888152602a60205260409020600c015415801590610eda57506000888152602a602090815260408220600c0154918052602d90527f6648a85983aca0407b603b260cacb25b5e5e8e5194522de3d8a800e71aa41bae54105b610ef65760405162461bcd60e51b81526004016101a690611d50565b6000888152602a60205260409020600e01541580610f4057506000888152602a60205260409020600e015415801590610f4057506000888152602a60205260409020600e01548610155b610f5c5760405162461bcd60e51b81526004016101a690611ddf565b6000888152602a60205260409020600d01541580610fa657506000888152602a60205260409020600d015415801590610fa657506000888152602a60205260409020600d01548611155b610fc25760405162461bcd60e51b81526004016101a690611d9d565b6000888152602a60205260409020600a015442101580610ff157506000888152602a60205260409020600a0154155b61100d5760405162461bcd60e51b81526004016101a690611e20565b6000888152602a60205260409020600b01544211158061103c57506000888152602a60205260409020600b0154155b6110585760405162461bcd60e51b81526004016101a690611ead565b60005b868110156110815761106e89868a6110ba565b5080611079816120d0565b91505061105b565b505050505050505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320546001600160a01b031690565b600080831561110b5760008481526013602052604090206001015484146110f35760405162461bcd60e51b81526004016101a690611d22565b506000838152601360205260409020600e015461111f565b506000848152602a60205260409020600201545b806111a95760008581526029602052604090205461113e90600161205e565b60008681526029602090815260409182902083905581516f61697264726f70546f6b656e53616c6560801b81830152606087901b6001600160601b03191660308201526044810189905260648082019490945282518082039094018452608401909152815191012090505b6040516304ebb1df60e51b815260048101869052602481018590526001600160a01b0384166044820152600160648201523090639d763be090608401600060405180830381600087803b1580156111ff57600080fd5b505af1158015611213573d6000803e3d6000fd5b5050506000858152602d6020526040812080546001935090919061123890849061205e565b90915550506000848152602c602090815260408083206001600160a01b0387168452909152812080546001929061127090849061205e565b9091555050604080518681526020810183905260018183015290516001600160a01b038516917f9724b007b03edd022b805a7acc9bbc33ce21a84b5c9e360a5f71b367b97db86d919081900360600190a2949350505050565b8280546112d590612095565b90600052602060002090601f0160209004810192826112f7576000855561133d565b82601f1061131057805160ff191683800117855561133d565b8280016001018555821561133d579182015b8281111561133d578251825591602001919060010190611322565b50611349929150611420565b5090565b60405180610220016040528060006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160006001600160a01b0316815260200160006001600160a01b0316815260200160608152602001606081526020016060815260200160001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200161141b604080516080810190915260008082526020820190815260200160008152602001600081525090565b905290565b5b808211156113495760008155600101611421565b80356001600160a01b038116811461144c57600080fd5b919050565b600082601f83011261146257600080fd5b813560206001600160401b0382111561147d5761147d612117565b8160051b61148c82820161202e565b8381528281019086840183880185018910156114a757600080fd5b600093505b858410156114ca5780358352600193909301929184019184016114ac565b50979650505050505050565b803561144c8161212d565b80356004811061144c57600080fd5b600082601f83011261150157600080fd5b81356001600160401b0381111561151a5761151a612117565b61152d601f8201601f191660200161202e565b81815284602083860101111561154257600080fd5b816020850160208301376000918101602001919091529392505050565b60006080828403121561157157600080fd5b604051608081016001600160401b038111828210171561159357611593612117565b604052823581529050806115a9602084016114e1565b602082015260408301356040820152606083013560608201525092915050565b600061028082840312156115dc57600080fd5b6115e4611fe2565b90506115ef82611435565b81526115fd60208301611435565b6020820152604082013560408201526060820135606082015261162260808301611435565b608082015261163360a08301611435565b60a082015260c08201356001600160401b038082111561165257600080fd5b61165e858386016114f0565b60c084015260e084013591508082111561167757600080fd5b611683858386016114f0565b60e08401526101009150818401358181111561169e57600080fd5b6116aa868287016114f0565b838501525050506101206116bf8184016114d6565b908201526101408281013590820152610160808301359082015261018080830135908201526101a080830135908201526101c080830135908201526101e080830135908201526102006117148482850161155f565b9082015292915050565b60006020828403121561173057600080fd5b815161173b8161212d565b9392505050565b60006101e0828403121561175557600080fd5b61175d61200b565b611766836114d6565b81526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013581830152506101406117d58582860161155f565b908201526101c0929092013561016083015250919050565b60008060006040848603121561180257600080fd5b83356001600160401b038082111561181957600080fd5b611825878388016115c9565b9450602086013591508082111561183b57600080fd5b818601915086601f83011261184f57600080fd5b81358181111561185e57600080fd5b8760206101e08302850101111561187457600080fd5b6020830194508093505050509250925092565b60006020828403121561189957600080fd5b5035919050565b600080600080600080600060e0888a0312156118bb57600080fd5b873596506118cb60208901611435565b955060408801359450606088013593506080880135925060a0880135915060c08801356001600160401b0381111561190257600080fd5b61190e8a828b01611451565b91505092959891949750929550565b6000806040838503121561193057600080fd5b8235915060208301356001600160401b0381111561194d57600080fd5b611959858286016115c9565b9150509250929050565b6000806000806080858703121561197957600080fd5b843593506020850135925061199060408601611435565b9396929550929360600135925050565b600080600080600080600060e0888a0312156119bb57600080fd5b8735965060208801359550604088013594506119d960608901611435565b93506080880135925060a0880135915060c08801356001600160401b0381111561190257600080fd5b6001600160a01b03169052565b600081518084526020808501945080840160005b83811015611a3f57815187529582019590820190600101611a23565b509495945050505050565b60048110611a6857634e487b7160e01b600052602160045260246000fd5b9052565b6000815180845260005b81811015611a9257602081850181015186830182015201611a76565b81811115611aa4576000602083870101525b50601f01601f19169290920160200192915050565b80358252611ac9602082016114e1565b611ad66020840182611a4a565b5060408181013590830152606090810135910152565b805182526020810151611b026020840182611a4a565b5060408181015190830152606090810151910152565b6000610280611b28848451611a02565b6020830151611b3a6020860182611a02565b5060408301516040850152606083015160608501526080830151611b616080860182611a02565b5060a0830151611b7460a0860182611a02565b5060c08301518160c0860152611b8c82860182611a6c565b91505060e083015184820360e0860152611ba68282611a6c565b9150506101008084015185830382870152611bc18382611a6c565b9250505061012080840151611bd98287018215159052565b50506101408381015190850152610160808401519085015261018080840151908501526101a080840151908501526101c080840151908501526101e0808401519085015261020080840151611c3082870182611aec565b5090949350505050565b604081526000611c4d6040830185611a0f565b90508260208301529392505050565b6020808252818101839052600090604080840186845b87811015611d1557611c8d83611c87846114d6565b15159052565b81850135838601528382013584840152606080830135908401526080808301359084015260a0808301359084015260c0808301359084015260e0808301359084015261010080830135908401526101208083013590840152610140611cf6818501828501611ab9565b506101c082810135908401526101e09283019290910190600101611c72565b5090979650505050505050565b602080825260149082015273105a5c991c9bdc08191bd95cdb9d08195e1a5cdd60621b604082015260600190565b6020808252602d908201527f546865206d6178696d756d20616d6f756e74206f6620746f6b656e732068617360408201526c103132b2b7103137bab3b43a1760991b606082015260800190565b60208082526022908201527f4d6178696d756d207175616e74697479207065722073616c6520657863656564604082015261195960f21b606082015260800190565b60208082526021908201527f4d696e696d756d207175616e74697479207065722073616c65206e6f74206d656040820152601d60fa1b606082015260800190565b6020808252601c908201527b151a19481cd85b19481a185cc81b9bdd081cdd185c9d1959081e595d60221b604082015260600190565b60208082526037908201527f455243313135353a206f6e6c792074686520636f6e7472616374206f776e65726040820152761031b0b71031b0b636103a3434b990333ab731ba34b7b760491b606082015260800190565b602080825260129082015271151a19481cd85b19481a185cc8195b99195960721b604082015260600190565b8151151581526101e081016020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151818401525061012080840151818401525061014080840151611f5582850182611aec565b50506101608301516101c083015292915050565b60208152600061173b6020830184611b18565b828152604060208201526000611f956040830184611b18565b949350505050565b86815285602082015260018060a01b038516604082015283606082015282608082015260c060a08201526000611fd660c0830184611a0f565b98975050505050505050565b60405161022081016001600160401b038111828210171561200557612005612117565b60405290565b60405161018081016001600160401b038111828210171561200557612005612117565b604051601f8201601f191681016001600160401b038111828210171561205657612056612117565b604052919050565b60008219821115612071576120716120eb565b500190565b6000816000190483118215151615612090576120906120eb565b500290565b600181811c908216806120a957607f821691505b602082108114156120ca57634e487b7160e01b600052602260045260246000fd5b50919050565b60006000198214156120e4576120e46120eb565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b801515811461213b57600080fd5b5056fea264697066735822122064e22bee4a430ae7c0e4cf20583f568b14cb2a175934b8c0191b183ebfb9a36c64736f6c63430008060033",
  "libraries": {
    "AddressSet": "0xf88EB844922B1ab0e153cF9E9bEefecc9512DE06",
    "UInt256Set": "0xCc995d7a8c7c499128cB34Ef0dA290F5f4f4EE71",
    "LibAppStorage": "0x36DFFA53Be73EC4DC419d32142dce5577DbBe7DA",
    "LibDiamond": "0xd77fa05d7Fba908919b3A4b9E41Cc62A1A7F728D",
    "MerkleProof": "0xe2f6D7E396B31d50dc5d11aD23c17859aDc95bB3"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createTokenSale((address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)),(bool,uint256,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256),uint256)[])": {
        "params": {
          "tokenSaleInit": "struct with tokensale data"
        }
      },
      "newAirdrop((bool,uint256,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256),uint256))": {
        "params": {
          "_airdrop": "the id of the airdrop"
        }
      },
      "redeemToken(uint256,uint256,uint256,address,uint256,uint256,bytes32[])": {
        "params": {
          "amount": "- the seed",
          "drop": "- the address of the account receiving the item",
          "leaf": "- the seed",
          "merkleProof": "- the seed",
          "recipient": "- the seed"
        }
      },
      "updateTokenSaleSettings(uint256,(address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)))": {
        "params": {
          "settings": "- the token sake settings"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "TokenPurchased(uint256,address,uint256,uint256)": {
        "notice": "emitted when a token is opened"
      },
      "TokenSaleClosed(uint256,(address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)))": {
        "notice": "emitted when a token is opened"
      },
      "TokenSaleOpen(uint256,(address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)))": {
        "notice": "emitted when a token is opened"
      }
    },
    "kind": "user",
    "methods": {
      "createTokenSale((address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)),(bool,uint256,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256),uint256)[])": {
        "notice": "intialize the contract. should be called by overriding contract"
      },
      "getTokenSaleSettings(uint256)": {
        "notice": "Get the token sale settings"
      },
      "newAirdrop((bool,uint256,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256),uint256))": {
        "notice": "add a new airdrop"
      },
      "updateTokenSaleSettings(uint256,(address,address,uint256,uint256,address,address,string,string,string,bool,uint256,uint256,uint256,uint256,uint256,uint256,(uint256,uint8,uint256,uint256)))": {
        "notice": "Updates the token sale settings"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2452,
        "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
        "label": "s",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(AppStorage)2440_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_address_payable": {
        "encoding": "inplace",
        "label": "address payable",
        "numberOfBytes": "20"
      },
      "t_array(t_string_storage)dyn_storage": {
        "base": "t_string_storage",
        "encoding": "dynamic_array",
        "label": "string[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(ForgeItemRequirement)6272_storage)dyn_storage": {
        "base": "t_struct(ForgeItemRequirement)6272_storage",
        "encoding": "dynamic_array",
        "label": "struct ForgeItemRequirement[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(Requirement)6784_storage)dyn_storage": {
        "base": "t_struct(Requirement)6784_storage",
        "encoding": "dynamic_array",
        "label": "struct IRequirement.Requirement[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(Token)6891_storage)dyn_storage": {
        "base": "t_struct(Token)6891_storage",
        "encoding": "dynamic_array",
        "label": "struct IToken.Token[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_enum(PriceModifier)7083": {
        "encoding": "inplace",
        "label": "enum ITokenPrice.PriceModifier",
        "numberOfBytes": "1"
      },
      "t_enum(TokenSourceType)6942": {
        "encoding": "inplace",
        "label": "enum IToken.TokenSourceType",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_address,t_struct(AddressData)6187_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct IERC721A.AddressData)",
        "numberOfBytes": "32",
        "value": "t_struct(AddressData)6187_storage"
      },
      "t_mapping(t_address,t_struct(FractionalizedTokenData)2306_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct FractionalizedTokenData)",
        "numberOfBytes": "32",
        "value": "t_struct(FractionalizedTokenData)2306_storage"
      },
      "t_mapping(t_address,t_struct(TokenSaleEntry)7125_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct ITokenSale.TokenSaleEntry)",
        "numberOfBytes": "32",
        "value": "t_struct(TokenSaleEntry)7125_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_string_memory_ptr,t_uint256)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_array(t_struct(Requirement)6784_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IRequirement.Requirement[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(Requirement)6784_storage)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_struct(Token)6891_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IToken.Token[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(Token)6891_storage)dyn_storage"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_uint256,t_mapping(t_string_memory_ptr,t_uint256))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(string => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_string_memory_ptr,t_uint256)"
      },
      "t_mapping(t_uint256,t_mapping(t_uint256,t_struct(ForgeItemDefinition)6293_storage))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(uint256 => struct ForgeItemDefinition))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_struct(ForgeItemDefinition)6293_storage)"
      },
      "t_mapping(t_uint256,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_uint256,t_struct(AirdropSettings)5195_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IAirdrop.AirdropSettings)",
        "numberOfBytes": "32",
        "value": "t_struct(AirdropSettings)5195_storage"
      },
      "t_mapping(t_uint256,t_struct(Claim)5386_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IClaim.Claim)",
        "numberOfBytes": "32",
        "value": "t_struct(Claim)5386_storage"
      },
      "t_mapping(t_uint256,t_struct(ForgeDefinition)6265_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ForgeDefinition)",
        "numberOfBytes": "32",
        "value": "t_struct(ForgeDefinition)6265_storage"
      },
      "t_mapping(t_uint256,t_struct(ForgeItemDefinition)6293_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ForgeItemDefinition)",
        "numberOfBytes": "32",
        "value": "t_struct(ForgeItemDefinition)6293_storage"
      },
      "t_mapping(t_uint256,t_struct(GemPoolStruct)6489_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IGemPool.GemPoolStruct)",
        "numberOfBytes": "32",
        "value": "t_struct(GemPoolStruct)6489_storage"
      },
      "t_mapping(t_uint256,t_struct(MarketItem)6753_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IMarketplace.MarketItem)",
        "numberOfBytes": "32",
        "value": "t_struct(MarketItem)6753_storage"
      },
      "t_mapping(t_uint256,t_struct(Set)8943_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct UInt256Set.Set)",
        "numberOfBytes": "32",
        "value": "t_struct(Set)8943_storage"
      },
      "t_mapping(t_uint256,t_struct(TokenOwnership)6178_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IERC721A.TokenOwnership)",
        "numberOfBytes": "32",
        "value": "t_struct(TokenOwnership)6178_storage"
      },
      "t_mapping(t_uint256,t_struct(TokenSaleSettings)5293_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IAirdropTokenSale.TokenSaleSettings)",
        "numberOfBytes": "32",
        "value": "t_struct(TokenSaleSettings)5293_storage"
      },
      "t_mapping(t_uint256,t_struct(TokenSet)6903_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IToken.TokenSet)",
        "numberOfBytes": "32",
        "value": "t_struct(TokenSet)6903_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(AddressData)6187_storage": {
        "encoding": "inplace",
        "label": "struct IERC721A.AddressData",
        "members": [
          {
            "astId": 6180,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "balance",
            "offset": 0,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 6182,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "numberMinted",
            "offset": 8,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 6184,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "numberBurned",
            "offset": 16,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 6186,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "aux",
            "offset": 24,
            "slot": "0",
            "type": "t_uint64"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(AirdropSettings)5195_storage": {
        "encoding": "inplace",
        "label": "struct IAirdrop.AirdropSettings",
        "members": [
          {
            "astId": 5171,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "whitelistOnly",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 5173,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "whitelistId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 5175,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "whitelistHash",
            "offset": 0,
            "slot": "2",
            "type": "t_bytes32"
          },
          {
            "astId": 5177,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxQuantity",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 5179,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxQuantityPerSale",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 5181,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "minQuantityPerSale",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 5183,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxQuantityPerAccount",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 5185,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "quantitySold",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 5187,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "startTime",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 5189,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "endTime",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 5192,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "initialPrice",
            "offset": 0,
            "slot": "10",
            "type": "t_struct(TokenPriceData)7093_storage"
          },
          {
            "astId": 5194,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenHash",
            "offset": 0,
            "slot": "14",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "480"
      },
      "t_struct(AirdropTokenSaleStorage)2351_storage": {
        "encoding": "inplace",
        "label": "struct AirdropTokenSaleStorage",
        "members": [
          {
            "astId": 2327,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tsnonce",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 2331,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "nonces",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_uint256)"
          },
          {
            "astId": 2336,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_tokenSales",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_struct(TokenSaleSettings)5293_storage)"
          },
          {
            "astId": 2340,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenSaleOpen",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_uint256,t_bool)"
          },
          {
            "astId": 2346,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "purchased",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_uint256,t_mapping(t_address,t_uint256))"
          },
          {
            "astId": 2350,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "totalPurchased",
            "offset": 0,
            "slot": "5",
            "type": "t_mapping(t_uint256,t_uint256)"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(AppStorage)2440_storage": {
        "encoding": "inplace",
        "label": "struct AppStorage",
        "members": [
          {
            "astId": 2394,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "marketplaceStorage",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(MarketplaceStorage)2284_storage"
          },
          {
            "astId": 2397,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenMinterStorage",
            "offset": 0,
            "slot": "4",
            "type": "t_struct(TokenMinterStorage)2293_storage"
          },
          {
            "astId": 2400,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "erc1155Storage",
            "offset": 0,
            "slot": "7",
            "type": "t_struct(ERC1155Storage)2205_storage"
          },
          {
            "astId": 2403,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "fractionalizerStorage",
            "offset": 0,
            "slot": "15",
            "type": "t_struct(FractionalizerStorage)2314_storage"
          },
          {
            "astId": 2406,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "marketUtilsStorage",
            "offset": 0,
            "slot": "17",
            "type": "t_struct(MarketUtilsStorage)2382_storage"
          },
          {
            "astId": 2409,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenSaleStorage",
            "offset": 0,
            "slot": "18",
            "type": "t_struct(TokenSaleStorage)2320_storage"
          },
          {
            "astId": 2412,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "merkleAirdropStorage",
            "offset": 0,
            "slot": "19",
            "type": "t_struct(MerkleAirdropStorage)2377_storage"
          },
          {
            "astId": 2415,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "erc721AStorage",
            "offset": 0,
            "slot": "24",
            "type": "t_struct(ERC721AStorage)2234_storage"
          },
          {
            "astId": 2418,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "erc2981Storage",
            "offset": 0,
            "slot": "32",
            "type": "t_struct(ERC2981Storage)2243_storage"
          },
          {
            "astId": 2421,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "attributeMutationPoolStorage",
            "offset": 0,
            "slot": "34",
            "type": "t_struct(AttributeMutationPoolStorage)2258_storage"
          },
          {
            "astId": 2424,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenAttributeStorage",
            "offset": 0,
            "slot": "39",
            "type": "t_struct(TokenAttributeStorage)2265_storage"
          },
          {
            "astId": 2427,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "airdropTokenSaleStorage",
            "offset": 0,
            "slot": "40",
            "type": "t_struct(AirdropTokenSaleStorage)2351_storage"
          },
          {
            "astId": 2430,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "feeManagerStorage",
            "offset": 0,
            "slot": "46",
            "type": "t_struct(FeeManagerStorage)2325_storage"
          },
          {
            "astId": 2433,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "bankStorage",
            "offset": 0,
            "slot": "47",
            "type": "t_struct(BankStorage)2391_storage"
          },
          {
            "astId": 2436,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgeStorage",
            "offset": 0,
            "slot": "49",
            "type": "t_struct(ForgeStorage)2176_storage"
          },
          {
            "astId": 2439,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "gemPoolStorage",
            "offset": 0,
            "slot": "57",
            "type": "t_struct(GemPoolStorage)2146_storage"
          }
        ],
        "numberOfBytes": "2272"
      },
      "t_struct(AttributeMutationPoolStorage)2258_storage": {
        "encoding": "inplace",
        "label": "struct AttributeMutationPoolStorage",
        "members": [
          {
            "astId": 2245,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_attributeKey",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 2247,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_attributeValuePerPeriod",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 2249,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_attributeBlocksPerPeriod",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 2251,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_totalValueThreshold",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 2257,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_tokenDepositHeight",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(BankStorage)2391_storage": {
        "encoding": "inplace",
        "label": "struct BankStorage",
        "members": [
          {
            "astId": 2384,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "token",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 2390,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "balances",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Claim)5386_storage": {
        "encoding": "inplace",
        "label": "struct IClaim.Claim",
        "members": [
          {
            "astId": 5361,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "id",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 5363,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "poolId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 5365,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "creator",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 5367,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "minter",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 5369,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "depositAmount",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 5371,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "depositToken",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 5373,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "mintQuantity",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 5375,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "depositLength",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 5377,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "createdTime",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 5379,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "createdBlock",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 5381,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "claimedBlock",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 5383,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "gemHash",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          },
          {
            "astId": 5385,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "feePaid",
            "offset": 0,
            "slot": "12",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "416"
      },
      "t_struct(ERC1155Storage)2205_storage": {
        "encoding": "inplace",
        "label": "struct ERC1155Storage",
        "members": [
          {
            "astId": 2182,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_balances",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_mapping(t_address,t_uint256))"
          },
          {
            "astId": 2188,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_operatorApprovals",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
          },
          {
            "astId": 2194,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_minterApprovals",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
          },
          {
            "astId": 2196,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_uri",
            "offset": 0,
            "slot": "3",
            "type": "t_string_storage"
          },
          {
            "astId": 2198,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_uriBase",
            "offset": 0,
            "slot": "4",
            "type": "t_string_storage"
          },
          {
            "astId": 2200,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_symbol",
            "offset": 0,
            "slot": "5",
            "type": "t_string_storage"
          },
          {
            "astId": 2202,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_name",
            "offset": 0,
            "slot": "6",
            "type": "t_string_storage"
          },
          {
            "astId": 2204,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_approvalProxy",
            "offset": 0,
            "slot": "7",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "256"
      },
      "t_struct(ERC2981Storage)2243_storage": {
        "encoding": "inplace",
        "label": "struct ERC2981Storage",
        "members": [
          {
            "astId": 2238,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "royaltyReceiversByHash",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_address)"
          },
          {
            "astId": 2242,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "royaltyFeesByHash",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_uint256)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(ERC721AStorage)2234_storage": {
        "encoding": "inplace",
        "label": "struct ERC721AStorage",
        "members": [
          {
            "astId": 2207,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_currentIndex",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 2209,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_burnCounter",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 2211,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_name",
            "offset": 0,
            "slot": "2",
            "type": "t_string_storage"
          },
          {
            "astId": 2213,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_symbol",
            "offset": 0,
            "slot": "3",
            "type": "t_string_storage"
          },
          {
            "astId": 2218,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_ownerships",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_uint256,t_struct(TokenOwnership)6178_storage)"
          },
          {
            "astId": 2223,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_addressData",
            "offset": 0,
            "slot": "5",
            "type": "t_mapping(t_address,t_struct(AddressData)6187_storage)"
          },
          {
            "astId": 2227,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_tokenApprovals",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_uint256,t_address)"
          },
          {
            "astId": 2233,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_operatorApprovals",
            "offset": 0,
            "slot": "7",
            "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
          }
        ],
        "numberOfBytes": "256"
      },
      "t_struct(FeeManagerStorage)2325_storage": {
        "encoding": "inplace",
        "label": "struct FeeManagerStorage",
        "members": [
          {
            "astId": 2324,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_fees",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_string_memory_ptr,t_uint256)"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(ForgeDefinition)6265_storage": {
        "encoding": "inplace",
        "label": "struct ForgeDefinition",
        "members": [
          {
            "astId": 6252,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgeId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 6254,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "name",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 6256,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "symbol",
            "offset": 0,
            "slot": "2",
            "type": "t_string_storage"
          },
          {
            "astId": 6258,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "description",
            "offset": 0,
            "slot": "3",
            "type": "t_string_storage"
          },
          {
            "astId": 6260,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxForgeCount",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 6262,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgedCount",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 6264,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgeFee",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(ForgeItemDefinition)6293_storage": {
        "encoding": "inplace",
        "label": "struct ForgeItemDefinition",
        "members": [
          {
            "astId": 6274,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "name",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 6276,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "symbol",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 6278,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "description",
            "offset": 0,
            "slot": "2",
            "type": "t_string_storage"
          },
          {
            "astId": 6282,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "requirements",
            "offset": 0,
            "slot": "3",
            "type": "t_array(t_struct(ForgeItemRequirement)6272_storage)dyn_storage"
          },
          {
            "astId": 6284,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "probability",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 6286,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxForgeCount",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 6288,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgedCount",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 6290,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgeFee",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 6292,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenHash",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "288"
      },
      "t_struct(ForgeItemRequirement)6272_storage": {
        "encoding": "inplace",
        "label": "struct ForgeItemRequirement",
        "members": [
          {
            "astId": 6267,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenAddress",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 6269,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 6271,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "amount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(ForgeStorage)2176_storage": {
        "encoding": "inplace",
        "label": "struct ForgeStorage",
        "members": [
          {
            "astId": 2151,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forges",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_struct(ForgeDefinition)6265_storage)"
          },
          {
            "astId": 2154,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgeIds",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 2161,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgeItems",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_mapping(t_uint256,t_struct(ForgeItemDefinition)6293_storage))"
          },
          {
            "astId": 2164,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgeItemIds",
            "offset": 0,
            "slot": "3",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 2169,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "forgedItemHashes",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_uint256,t_struct(Set)8943_storage)"
          },
          {
            "astId": 2172,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "allforgedItemHashes",
            "offset": 0,
            "slot": "5",
            "type": "t_struct(Set)8943_storage"
          },
          {
            "astId": 2175,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "symbols",
            "offset": 0,
            "slot": "7",
            "type": "t_array(t_string_storage)dyn_storage"
          }
        ],
        "numberOfBytes": "256"
      },
      "t_struct(FractionalizedTokenData)2306_storage": {
        "encoding": "inplace",
        "label": "struct FractionalizedTokenData",
        "members": [
          {
            "astId": 2295,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "symbol",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 2297,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "name",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 2299,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenAddress",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 2301,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenId",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 2303,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "fractionalizedToken",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 2305,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "totalFractions",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(FractionalizerStorage)2314_storage": {
        "encoding": "inplace",
        "label": "struct FractionalizerStorage",
        "members": [
          {
            "astId": 2308,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "fTokenTemplate",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 2313,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "fractionalizedTokens",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_struct(FractionalizedTokenData)2306_storage)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(GemPoolData)6442_storage": {
        "encoding": "inplace",
        "label": "struct IGemPool.GemPoolData",
        "members": [
          {
            "astId": 6433,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "pool",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 6435,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "nextGemHash",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 6437,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "nextGemNumber",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 6439,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "gemsMintedCount",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 6441,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "totalStakedEth",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(GemPoolSettings)6482_storage": {
        "encoding": "inplace",
        "label": "struct IGemPool.GemPoolSettings",
        "members": [
          {
            "astId": 6444,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "token",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 6447,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenSource",
            "offset": 0,
            "slot": "1",
            "type": "t_struct(TokenSource)6950_storage"
          },
          {
            "astId": 6450,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenDefinition",
            "offset": 0,
            "slot": "4",
            "type": "t_struct(TokenDefinition)6928_storage"
          },
          {
            "astId": 6453,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "initialPrice",
            "offset": 0,
            "slot": "16",
            "type": "t_struct(TokenPriceData)7093_storage"
          },
          {
            "astId": 6455,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "enabled",
            "offset": 0,
            "slot": "20",
            "type": "t_bool"
          },
          {
            "astId": 6457,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "visible",
            "offset": 1,
            "slot": "20",
            "type": "t_bool"
          },
          {
            "astId": 6459,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "minTime",
            "offset": 0,
            "slot": "21",
            "type": "t_uint256"
          },
          {
            "astId": 6461,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxTime",
            "offset": 0,
            "slot": "22",
            "type": "t_uint256"
          },
          {
            "astId": 6463,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "diffstep",
            "offset": 0,
            "slot": "23",
            "type": "t_uint256"
          },
          {
            "astId": 6465,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxClaims",
            "offset": 0,
            "slot": "24",
            "type": "t_uint256"
          },
          {
            "astId": 6467,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxQuantityPerClaim",
            "offset": 0,
            "slot": "25",
            "type": "t_uint256"
          },
          {
            "astId": 6469,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxClaimsPerAccount",
            "offset": 0,
            "slot": "26",
            "type": "t_uint256"
          },
          {
            "astId": 6471,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "earnRatePerPeriod",
            "offset": 0,
            "slot": "27",
            "type": "t_uint256"
          },
          {
            "astId": 6473,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "earnPeriodBlocks",
            "offset": 0,
            "slot": "28",
            "type": "t_uint256"
          },
          {
            "astId": 6475,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "payPartialBlocks",
            "offset": 0,
            "slot": "29",
            "type": "t_bool"
          },
          {
            "astId": 6477,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "mintEarnedToken",
            "offset": 1,
            "slot": "29",
            "type": "t_bool"
          },
          {
            "astId": 6479,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxTotalEarnedAmount",
            "offset": 0,
            "slot": "30",
            "type": "t_uint256"
          },
          {
            "astId": 6481,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "allowPurchase",
            "offset": 0,
            "slot": "31",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "1024"
      },
      "t_struct(GemPoolStorage)2146_storage": {
        "encoding": "inplace",
        "label": "struct GemPoolStorage",
        "members": [
          {
            "astId": 2117,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_gemPools",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_struct(GemPoolStruct)6489_storage)"
          },
          {
            "astId": 2122,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_recordHashes",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_struct(Set)8943_storage)"
          },
          {
            "astId": 2128,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_bankedRequirements",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_array(t_struct(Token)6891_storage)dyn_storage)"
          },
          {
            "astId": 2133,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_claims",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_uint256,t_struct(Claim)5386_storage)"
          },
          {
            "astId": 2135,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_claimIndex",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 2139,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_stakedTotal",
            "offset": 0,
            "slot": "5",
            "type": "t_mapping(t_address,t_uint256)"
          },
          {
            "astId": 2142,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_requirementData",
            "offset": 0,
            "slot": "6",
            "type": "t_struct(RequirementData)6807_storage"
          },
          {
            "astId": 2145,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_symbols",
            "offset": 0,
            "slot": "13",
            "type": "t_array(t_string_storage)dyn_storage"
          }
        ],
        "numberOfBytes": "448"
      },
      "t_struct(GemPoolStruct)6489_storage": {
        "encoding": "inplace",
        "label": "struct IGemPool.GemPoolStruct",
        "members": [
          {
            "astId": 6485,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_gemPoolSettings",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(GemPoolSettings)6482_storage"
          },
          {
            "astId": 6488,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_gemPoolData",
            "offset": 0,
            "slot": "32",
            "type": "t_struct(GemPoolData)6442_storage"
          }
        ],
        "numberOfBytes": "1184"
      },
      "t_struct(MarketItem)6753_storage": {
        "encoding": "inplace",
        "label": "struct IMarketplace.MarketItem",
        "members": [
          {
            "astId": 6736,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "itemId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 6738,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "nftContract",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 6740,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenId",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 6742,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "seller",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 6744,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "owner",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 6746,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "price",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 6748,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "quantity",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 6750,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "sold",
            "offset": 0,
            "slot": "7",
            "type": "t_bool"
          },
          {
            "astId": 6752,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "receiver",
            "offset": 1,
            "slot": "7",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "256"
      },
      "t_struct(MarketUtilsStorage)2382_storage": {
        "encoding": "inplace",
        "label": "struct MarketUtilsStorage",
        "members": [
          {
            "astId": 2381,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "validTokens",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_bool)"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(MarketplaceStorage)2284_storage": {
        "encoding": "inplace",
        "label": "struct MarketplaceStorage",
        "members": [
          {
            "astId": 2272,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "itemsSold",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 2274,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "itemIds",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 2279,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "idToMarketItem",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_struct(MarketItem)6753_storage)"
          },
          {
            "astId": 2283,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "idToListed",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_uint256,t_bool)"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(MerkleAirdropStorage)2377_storage": {
        "encoding": "inplace",
        "label": "struct MerkleAirdropStorage",
        "members": [
          {
            "astId": 2356,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_settings",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_struct(AirdropSettings)5195_storage)"
          },
          {
            "astId": 2358,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "numSettings",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 2364,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_redeemedData",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_mapping(t_uint256,t_uint256))"
          },
          {
            "astId": 2370,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_redeemedDataQuantities",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_uint256,t_mapping(t_address,t_uint256))"
          },
          {
            "astId": 2376,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_totalDataQuantities",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_uint256,t_mapping(t_address,t_uint256))"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(Requirement)6784_storage": {
        "encoding": "inplace",
        "label": "struct IRequirement.Requirement",
        "members": [
          {
            "astId": 6772,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "minter",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 6775,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "source",
            "offset": 0,
            "slot": "1",
            "type": "t_struct(TokenSource)6950_storage"
          },
          {
            "astId": 6777,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "quantity",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 6779,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "takeCustody",
            "offset": 0,
            "slot": "5",
            "type": "t_bool"
          },
          {
            "astId": 6781,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "burn",
            "offset": 1,
            "slot": "5",
            "type": "t_bool"
          },
          {
            "astId": 6783,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "requireExactAmount",
            "offset": 2,
            "slot": "5",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(RequirementData)6807_storage": {
        "encoding": "inplace",
        "label": "struct IRequirement.RequirementData",
        "members": [
          {
            "astId": 6786,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "token",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 6788,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "manager",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 6794,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "requirements",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_array(t_struct(Requirement)6784_storage)dyn_storage)"
          },
          {
            "astId": 6799,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokens",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_uint256,t_struct(TokenSet)6903_storage)"
          },
          {
            "astId": 6802,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "burnedTokenIds",
            "offset": 0,
            "slot": "4",
            "type": "t_struct(Set)8943_storage"
          },
          {
            "astId": 6806,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "burnedTokenQuantities",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_uint256,t_uint256)"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(Set)8943_storage": {
        "encoding": "inplace",
        "label": "struct UInt256Set.Set",
        "members": [
          {
            "astId": 8939,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "keyPointers",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_uint256)"
          },
          {
            "astId": 8942,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "keyList",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_uint256)dyn_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Token)6891_storage": {
        "encoding": "inplace",
        "label": "struct IToken.Token",
        "members": [
          {
            "astId": 6886,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "id",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 6888,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "balance",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 6890,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "burn",
            "offset": 0,
            "slot": "2",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(TokenAttributeStorage)2265_storage": {
        "encoding": "inplace",
        "label": "struct TokenAttributeStorage",
        "members": [
          {
            "astId": 2264,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "attributes",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_mapping(t_string_memory_ptr,t_uint256))"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(TokenDefinition)6928_storage": {
        "encoding": "inplace",
        "label": "struct IToken.TokenDefinition",
        "members": [
          {
            "astId": 6905,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "token",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 6907,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "id",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 6909,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "collectionId",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 6911,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "name",
            "offset": 0,
            "slot": "3",
            "type": "t_string_storage"
          },
          {
            "astId": 6913,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "symbol",
            "offset": 0,
            "slot": "4",
            "type": "t_string_storage"
          },
          {
            "astId": 6915,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "description",
            "offset": 0,
            "slot": "5",
            "type": "t_string_storage"
          },
          {
            "astId": 6917,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "decimals",
            "offset": 0,
            "slot": "6",
            "type": "t_uint8"
          },
          {
            "astId": 6919,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "totalSupply",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 6921,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "generateId",
            "offset": 0,
            "slot": "8",
            "type": "t_bool"
          },
          {
            "astId": 6923,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "probability",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 6925,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "probabilityIndex",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 6927,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "probabilityRoll",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "384"
      },
      "t_struct(TokenMinterStorage)2293_storage": {
        "encoding": "inplace",
        "label": "struct TokenMinterStorage",
        "members": [
          {
            "astId": 2286,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "token",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 2288,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_tokenCounter",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 2292,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_tokenMinters",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_address)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(TokenOwnership)6178_storage": {
        "encoding": "inplace",
        "label": "struct IERC721A.TokenOwnership",
        "members": [
          {
            "astId": 6173,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "addr",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 6175,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "startTimestamp",
            "offset": 20,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 6177,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "burned",
            "offset": 28,
            "slot": "0",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(TokenPriceData)7093_storage": {
        "encoding": "inplace",
        "label": "struct ITokenPrice.TokenPriceData",
        "members": [
          {
            "astId": 7085,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "price",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 7088,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "priceModifier",
            "offset": 0,
            "slot": "1",
            "type": "t_enum(PriceModifier)7083"
          },
          {
            "astId": 7090,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "priceModifierFactor",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 7092,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxPrice",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(TokenSaleEntry)7125_storage": {
        "encoding": "inplace",
        "label": "struct ITokenSale.TokenSaleEntry",
        "members": [
          {
            "astId": 7112,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "receiver",
            "offset": 0,
            "slot": "0",
            "type": "t_address_payable"
          },
          {
            "astId": 7114,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "sourceToken",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 7116,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "sourceTokenId",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 7118,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "token",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 7120,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "quantity",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 7122,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "price",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 7124,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "quantitySold",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(TokenSaleSettings)5293_storage": {
        "encoding": "inplace",
        "label": "struct IAirdropTokenSale.TokenSaleSettings",
        "members": [
          {
            "astId": 5259,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "contractAddress",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 5261,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "token",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 5263,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenHash",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 5265,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "collectionHash",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 5267,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "owner",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 5269,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "payee",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 5271,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "symbol",
            "offset": 0,
            "slot": "6",
            "type": "t_string_storage"
          },
          {
            "astId": 5273,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "name",
            "offset": 0,
            "slot": "7",
            "type": "t_string_storage"
          },
          {
            "astId": 5275,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "description",
            "offset": 0,
            "slot": "8",
            "type": "t_string_storage"
          },
          {
            "astId": 5277,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "openState",
            "offset": 0,
            "slot": "9",
            "type": "t_bool"
          },
          {
            "astId": 5279,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "startTime",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 5281,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "endTime",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          },
          {
            "astId": 5283,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxQuantity",
            "offset": 0,
            "slot": "12",
            "type": "t_uint256"
          },
          {
            "astId": 5285,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxQuantityPerSale",
            "offset": 0,
            "slot": "13",
            "type": "t_uint256"
          },
          {
            "astId": 5287,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "minQuantityPerSale",
            "offset": 0,
            "slot": "14",
            "type": "t_uint256"
          },
          {
            "astId": 5289,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "maxQuantityPerAccount",
            "offset": 0,
            "slot": "15",
            "type": "t_uint256"
          },
          {
            "astId": 5292,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "initialPrice",
            "offset": 0,
            "slot": "16",
            "type": "t_struct(TokenPriceData)7093_storage"
          }
        ],
        "numberOfBytes": "640"
      },
      "t_struct(TokenSaleStorage)2320_storage": {
        "encoding": "inplace",
        "label": "struct TokenSaleStorage",
        "members": [
          {
            "astId": 2319,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "tokenSaleEntries",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_struct(TokenSaleEntry)7125_storage)"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(TokenSet)6903_storage": {
        "encoding": "inplace",
        "label": "struct IToken.TokenSet",
        "members": [
          {
            "astId": 6895,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "keyPointers",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_uint256)"
          },
          {
            "astId": 6898,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "keyList",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 6902,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "valueList",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_struct(Token)6891_storage)dyn_storage"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(TokenSource)6950_storage": {
        "encoding": "inplace",
        "label": "struct IToken.TokenSource",
        "members": [
          {
            "astId": 6945,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "_type",
            "offset": 0,
            "slot": "0",
            "type": "t_enum(TokenSourceType)6942"
          },
          {
            "astId": 6947,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "staticSourceId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 6949,
            "contract": "contracts/facets/AirdropTokenSaleFacet.sol:AirdropTokenSaleFacet",
            "label": "collectionSourceAddress",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}