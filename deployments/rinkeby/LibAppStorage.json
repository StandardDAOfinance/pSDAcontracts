{
  "address": "0x6cfa6c2c41453855A7547426cDF22fE5690439cD",
  "abi": [],
  "transactionHash": "0x04d96223f61aa9656f8a2a054de853499f4eea50fc918ca39f786232c3135bba",
  "receipt": {
    "to": null,
    "from": "0x97AEd3F8aaCbcB22b374aC49bC2354374f17235a",
    "contractAddress": "0x6cfa6c2c41453855A7547426cDF22fE5690439cD",
    "transactionIndex": 32,
    "gasUsed": "72217",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9a93c9ca1340d8f91ff1c6b1331ae61a00203652f033e77cffa16c639ccc4015",
    "transactionHash": "0x04d96223f61aa9656f8a2a054de853499f4eea50fc918ca39f786232c3135bba",
    "logs": [],
    "blockNumber": 10584231,
    "cumulativeGasUsed": "4948991",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "afe5007c1f3b66f010b53beae8f59210",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/diamond/LibAppStorage.sol\":\"LibAppStorage\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":5},\"remappings\":[]},\"sources\":{\"contracts/diamond/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/UInt256Set.sol\\\";\\nimport \\\"../utils/AddressSet.sol\\\";\\n\\nimport \\\"../interfaces/ITokenMinter.sol\\\";\\nimport \\\"../interfaces/IAirdropTokenSale.sol\\\";\\nimport \\\"../interfaces/IERC721A.sol\\\";\\n\\nimport {LibDiamond} from \\\"./LibDiamond.sol\\\";\\n\\n// merkle utils storage\\nstruct MerkleUtilsStorage {\\n    mapping(uint256 => uint256) tokenHashToIds;\\n}\\n\\n// token minter storage\\nstruct TokenMinterStorage {\\n    address token;\\n}\\n\\nstruct AirdropTokenSaleStorage {\\n    uint256 tsnonce;\\n    mapping(uint256 => uint256) nonces;\\n    // token sale settings\\n    mapping(uint256 => IAirdropTokenSale.TokenSaleSettings) _tokenSales;\\n    // is token sale open\\n    mapping(uint256 => bool) tokenSaleOpen;\\n    // total purchased tokens per drop - 0 for public tokensale\\n    mapping(uint256 => mapping(address => uint256)) purchased;\\n    // total purchased tokens per drop - 0 for public tokensale\\n    mapping(uint256 => uint256) totalPurchased;\\n}\\n\\nstruct MerkleAirdropStorage {\\n    mapping (uint256 => IAirdrop.AirdropSettings) _settings;\\n    uint256 numSettings;\\n    mapping (uint256 => mapping(uint256 => uint256)) _redeemedData;\\n    mapping (uint256 => mapping(address => uint256)) _redeemedDataQuantities;\\n    mapping (uint256 => mapping(address => uint256)) _totalDataQuantities;\\n}\\n\\nstruct MarketUtilsStorage {\\n    mapping(uint256 => bool) validTokens;\\n}\\n\\nstruct AppStorage {\\n\\n    // merkle airdrop storage\\n    MerkleAirdropStorage merkleAirdropStorage;\\n   \\n    // airdrop token sale storage\\n    AirdropTokenSaleStorage airdropTokenSaleStorage;\\n\\n    // token minter storage\\n    TokenMinterStorage tokenMinterStorage;\\n}\\n\\nlibrary LibAppStorage {\\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\\n        assembly {\\n            ds.slot := 0\\n        }\\n    }\\n}\\n\\ncontract Modifiers {\\n    AppStorage internal s;\\n    modifier onlyOwner() {\\n        require(LibDiamond.contractOwner() == msg.sender || address(this) == msg.sender, \\\"ERC1155: only the contract owner can call this function\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x6f78552f52a74c15af6db97f4532523421b725b81e580268630e36b0cf99ab30\",\"license\":\"MIT\"},\"contracts/diamond/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n/// @notice Defines the data structures that are used to store the data for a diamond\\nlibrary LibDiamond {\\n    // the diamond storage position\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    /// @notice Stores the function selectors located within the Diamond\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    /// @notice Returns the storage position of the diamond\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    // event is generated when the diamond ownership is transferred\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice set the diamond contract owner\\n    /// @param _newOwner the new owner of the diamond\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    /// @notice returns the diamond contract owner\\n    /// @return contractOwner_ the diamond contract owner\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    /// @notice enforce contract ownership by requiring the caller to be the contract owner\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /// @notice add or replace facet selectors\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n            // \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(address(bytes20(oldFacet)) != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n                    // only useful if immutable functions exist\\n                    require(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    // \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    // \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    /// @notice initialise the DiamondCut contract\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0xdec0822acba9b539929f2c34457a02138bd28fd083a8feefb10a65e554f0124a\",\"license\":\"MIT\"},\"contracts/interfaces/IAirdrop.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IToken.sol\\\";\\nimport \\\"./ITokenPrice.sol\\\";\\nimport \\\"./IAirdropTokenSale.sol\\\";\\n\\ninterface IMerkleAirdrop {\\n    function airdropRedeemed(\\n        uint256 drop,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n     function initMerkleAirdrops(IAirdrop.AirdropSettings[] calldata settingsList) external;\\n     function airdrop(uint256 drop) external view returns (IAirdrop.AirdropSettings memory settings);\\n     function airdropRedeemed(uint256 drop, address recipient) external view returns (bool isRedeemed);\\n}\\n\\n/// @notice an airdrop airdrops tokens\\ninterface IAirdrop {\\n\\n    // emitted when airdrop is redeemed\\n\\n\\n    /// @notice the settings for the token sale,\\n    struct AirdropSettings {\\n        // sell from the whitelist only\\n        bool whitelistOnly;\\n\\n        // this whitelist id - by convention is the whitelist hash\\n        uint256 whitelistId;\\n\\n        // the root hash of the merkle tree\\n        bytes32 whitelistHash;\\n\\n        // quantities\\n        uint256 maxQuantity; // max number of tokens that can be sold\\n        uint256 maxQuantityPerSale; // max number of tokens that can be sold per sale\\n        uint256 minQuantityPerSale; // min number of tokens that can be sold per sale\\n        uint256 maxQuantityPerAccount; // max number of tokens that can be sold per account\\n\\n        // quantity of item sold\\n        uint256 quantitySold;\\n\\n        // start timne and end time for token sale\\n        uint256 startTime; // block number when the sale starts\\n        uint256 endTime; // block number when the sale ends\\n\\n        // inital price of the token sale\\n        ITokenPrice.TokenPriceData initialPrice;\\n\\n        // token hash\\n        uint256 tokenHash;\\n\\n        IAirdropTokenSale.PaymentType paymentType; // the type of payment that is being used\\n        address tokenAddress; // the address of the payment token, if payment type is TOKEN\\n    }\\n\\n    // emitted when airdrop is launched\\n    event AirdropLaunched(uint256 indexed airdropId, AirdropSettings airdrop);\\n\\n    // emitted when airdrop is redeemed\\n    event AirdropRedeemed(uint256 indexed airdropId, address indexed beneficiary, uint256 indexed tokenHash, bytes32[] proof, uint256 amount);\\n\\n    /// @notice airdrops check to see if proof is redeemed\\n    /// @param drop the id of the airdrop\\n    /// @param recipient the merkle proof\\n    /// @return isRedeemed the amount of tokens redeemed\\n    function airdropRedeemed(uint256 drop, address recipient) external view returns (bool isRedeemed);\\n\\n    /// @notice redeem tokens for airdrop\\n    /// @param drop the airdrop id\\n    /// @param leaf the index of the token in the airdrop\\n    /// @param recipient the beneficiary of the tokens\\n    /// @param amount tje amount of tokens to redeem\\n    /// @param merkleProof the merkle proof of the token\\n    function redeemAirdrop(uint256 drop, uint256 leaf, address recipient, uint256 amount, uint256 total, bytes32[] memory merkleProof) external payable;\\n\\n    /// @notice Get the token sale settings\\n    /// @return settings the token sale settings\\n    function airdrop(uint256 drop) external view returns (AirdropSettings memory settings);\\n\\n}\\n\",\"keccak256\":\"0x830144f6545e53a74de16ef43e119f9c183ebec47e3bb163738c2dba95bbed9d\",\"license\":\"Unlicense\"},\"contracts/interfaces/IAirdropTokenSale.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ITokenPrice.sol\\\";\\nimport \\\"./IAirdrop.sol\\\";\\n\\n/// @notice A token seller is a contract that can sell tokens to a token buyer.\\n/// The token buyer can buy tokens from the seller by paying a certain amount\\n/// of base currency to receive a certain amount of erc1155 tokens. the number\\n/// of tokens that can be bought is limited by the seller - the seller can\\n/// specify the maximum number of tokens that can be bought per transaction\\n/// and the maximum number of tokens that can be bought in total for a given\\n/// address. The seller can also specify the price of erc1155 tokens and how\\n/// that price increases per successful transaction.\\ninterface IAirdropTokenSale {\\n\\n\\n    enum PaymentType {\\n        ETH,\\n        TOKEN\\n    }\\n\\n    /// @notice the settings for the token sale,\\n    struct TokenSaleSettings {\\n\\n        // addresses\\n        address contractAddress; // the contract doing the selling\\n        address token; // the token being sold\\n        uint256 tokenHash; // the token hash being sold. set to 0 to autocreate hash\\n        uint256 collectionHash; // the collection hash being sold. set to 0 to autocreate hash\\n        // owner and payee\\n        address owner; // the owner of the contract\\n        address payee; // the payee of the contract\\n\\n        string symbol; // the symbol of the token\\n        string name; // the name of the token\\n        string description; // the description of the token\\n\\n        // open state\\n        bool openState; // open or closed\\n        uint256 startTime; // block number when the sale starts\\n        uint256 endTime; // block number when the sale ends\\n\\n        // quantities\\n        uint256 maxQuantity; // max number of tokens that can be sold\\n        uint256 maxQuantityPerSale; // max number of tokens that can be sold per sale\\n        uint256 minQuantityPerSale; // min number of tokens that can be sold per sale\\n        uint256 maxQuantityPerAccount; // max number of tokens that can be sold per account\\n\\n        // inital price of the token sale\\n        ITokenPrice.TokenPriceData initialPrice;\\n\\n        PaymentType paymentType; // the type of payment that is being used\\n        address tokenAddress; // the address of the payment token, if payment type is TOKEN\\n\\n    }\\n\\n    /// @notice emitted when a token is opened\\n    event TokenSaleOpen (uint256 tokenSaleId, TokenSaleSettings tokenSale );\\n\\n    /// @notice emitted when a token is opened\\n    event TokenSaleClosed (uint256 tokenSaleId, TokenSaleSettings tokenSale );\\n\\n    /// @notice emitted when a token is opened\\n    event TokenPurchased (uint256 tokenSaleId, address indexed purchaser, uint256 tokenId, uint256 quantity );\\n\\n    // token settings were updated\\n    event TokenSaleSettingsUpdated (uint256 tokenSaleId, TokenSaleSettings tokenSale );\\n\\n    /// @notice Get the token sale settings\\n    /// @return settings the token sale settings\\n    function getTokenSaleSettings(uint256 tokenSaleId) external view returns (TokenSaleSettings memory settings);\\n\\n    /// @notice Updates the token sale settings\\n    /// @param settings - the token sake settings\\n    function updateTokenSaleSettings(uint256 iTokenSaleId, TokenSaleSettings memory settings) external;\\n\\n    function initTokenSale(\\n        TokenSaleSettings memory tokenSaleInit,\\n        IAirdrop.AirdropSettings[] calldata settingsList\\n    ) external;\\n}\\n\",\"keccak256\":\"0xadbefe93b099cc401ed06a46faff4f48856065f04f9d59db359fde204c5f6c6f\",\"license\":\"Unlicense\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"contracts/interfaces/IERC1155Burn.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// implemented by erc1155 tokens to allow burning\\ninterface IERC1155Burn {\\n\\n    /// @notice event emitted when tokens are burned\\n    event Burned(\\n        address target,\\n        uint256 tokenHash,\\n        uint256 amount\\n    );\\n\\n    /// @notice burn tokens of specified amount from the specified address\\n    /// @param target the burn target\\n    /// @param tokenHash the token hash to burn\\n    /// @param amount the amount to burn\\n    function burn(\\n        address target,\\n        uint256 tokenHash,\\n        uint256 amount\\n    ) external;\\n\\n\\n}\\n\",\"keccak256\":\"0xb211cef77f9a160fe66b21fe10d657d7ef1ce8b9570322fd22e216a7c8ff1697\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721A.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721A {\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n    }\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct AddressData {\\n        // Realistically, 2**64-1 is more than enough.\\n        uint64 balance;\\n        // Keeps track of mint count with minimal overhead for tokenomics.\\n        uint64 numberMinted;\\n        // Keeps track of burn count with minimal overhead for tokenomics.\\n        uint64 numberBurned;\\n        // For miscellaneous variable(s) pertaining to the address\\n        // (e.g. number of whitelist mint slots used).\\n        // If there are multiple variables, please pack them into a uint64.\\n        uint64 aux;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8596388de3dbd302c9f0ddd89adb30b88bca9bef09494dfc2c11a8560612d88c\",\"license\":\"MIT\"},\"contracts/interfaces/IToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n\\n/// @notice common struct definitions for tokens\\ninterface IToken {\\n\\n\\n    enum TokenType {\\n        ERC20,\\n        ERC721,\\n        ERC1155\\n    }\\n\\n    struct Token {\\n\\n        uint256 id;\\n        uint256 balance;\\n        bool burn;\\n\\n    }\\n\\n    /// @notice a set of tokens.\\n    struct TokenSet {\\n\\n        mapping(uint256 => uint256) keyPointers;\\n        uint256[] keyList;\\n        Token[] valueList;\\n\\n    }\\n\\n    /// @notice the definition for a token.\\n    struct TokenDefinition {\\n\\n        // the host multitoken\\n        address token;\\n\\n        // the id of the token definition. if static mint then also token hash\\n        uint256 id;\\n\\n        // the category name\\n        uint256 collectionId;\\n\\n        // the name of the token\\n        string name;\\n\\n        // the symbol of the token\\n        string symbol;\\n\\n        // the description of the token\\n        string description;\\n\\n        // the decimals of the token. 0 for NFT\\n        uint8 decimals;\\n\\n        // the total supply of the token\\n        uint256 totalSupply;\\n\\n        // whether to generate the id or not for new tokens. if false then we use id field of the definition to mint tokens\\n        bool generateId;\\n\\n        // probability of the item being awarded\\n        uint256 probability;\\n\\n         // the index of the probability in its array\\n        uint256 probabilityIndex;\\n\\n         // the index of the probability in its array\\n        uint256 probabilityRoll;\\n\\n    }\\n\\n    struct TokenRecord {\\n\\n        uint256 id;\\n        address owner;\\n        address minter;\\n        uint256 _type;\\n        uint256 balance;\\n\\n    }\\n\\n    /// @notice the token source type. Either a static source or a collection.\\n    enum TokenSourceType {\\n\\n        Static,\\n        Collection\\n\\n    }\\n\\n    /// @notice the token source. Specifies the source of the token - either a static source or a collection.\\n    struct TokenSource {\\n\\n        // the token source type\\n        TokenSourceType _type;\\n        // the source id if a static collection\\n        uint256 staticSourceId;\\n        // the collection source address if collection\\n        address collectionSourceAddress;\\n\\n    }\\n}\\n\",\"keccak256\":\"0x37288bbd845594ef413956da9bde6132a02eb88587b73c7254a1a926423bcab5\",\"license\":\"MIT\"},\"contracts/interfaces/ITokenMinter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IERC1155Burn.sol\\\";\\n\\n/**\\n * @notice This intreface provides a way for users to register addresses as permissioned minters, mint * burn, unregister, and reload the permissioned minter account.\\n */\\ninterface ITokenMinter {\\n\\n    /// @notice a registration record for a permissioned minter.\\n    struct Minter {\\n\\n        // the account address of the permissioned minter.\\n        address account;\\n        // the amount of tokens minted by the permissioned minter.\\n        uint256 minted;\\n        // the amount of tokens minted by the permissioned minter.\\n        uint256 burned;\\n        // the amount of payment spent by the permissioned minter.\\n        uint256 spent;\\n        // an approval map for this minter. sets a count of tokens the approved can mint.\\n        // mapping(address => uint256) approved; // TODO implement this.\\n\\n    }\\n\\n    /// @notice event emitted when minter is registered\\n    event MinterRegistered(\\n        address indexed registrant,\\n        uint256 depositPaid\\n    );\\n\\n    /// @notice emoitted when minter is unregistered\\n    event MinterUnregistered(\\n        address indexed registrant,\\n        uint256 depositReturned\\n    );\\n\\n    /// @notice emitted when minter address is reloaded\\n    event MinterReloaded(\\n        address indexed registrant,\\n        uint256 amountDeposited\\n    );\\n\\n    /// @notice get the registration record for a permissioned minter.\\n    /// @param _minter the address\\n    /// @return _minterObj the address\\n    function minter(address _minter) external returns (Minter memory _minterObj);\\n\\n    /// @notice mint a token associated with a collection with an amount\\n    /// @param receiver the mint receiver\\n    /// @param collectionId the collection id\\n    /// @param amount the amount to mint\\n    function mint(address receiver, uint256 collectionId, uint256 id, uint256 amount) external;\\n\\n    /// @notice mint a token associated with a collection with an amount\\n    /// @param target the mint receiver\\n    /// @param id the collection id\\n    /// @param amount the amount to mint\\n    function burn(address target, uint256 id, uint256 amount) external;\\n\\n}\\n\",\"keccak256\":\"0xeed55742206b89aa5b45f8872e2af6a05f6976ca44f6e9e89b24b2761880ec55\",\"license\":\"MIT\"},\"contracts/interfaces/ITokenPrice.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n\\n/// @notice common struct definitions for tokens\\ninterface ITokenPrice {\\n\\n    /// @notice DIctates how the price of the token is increased post every sale\\n    enum PriceModifier {\\n\\n        None,\\n        Fixed,\\n        Exponential,\\n        InverseLog\\n\\n    }\\n\\n    /// @notice a token price and how it changes\\n    struct TokenPriceData {\\n\\n        // the price of the token\\n        uint256 price;\\n         // how the price is modified\\n        PriceModifier priceModifier;\\n        // only used if priceModifier is EXPONENTIAL or INVERSELOG or FIXED\\n        uint256 priceModifierFactor;\\n        // max price for the token\\n        uint256 maxPrice;\\n\\n    }\\n\\n    /// @notice get the increased price of the token\\n    function getIncreasedPrice() external view returns (uint256);\\n\\n    /// @notice get the increased price of the token\\n    function getTokenPrice() external view returns (TokenPriceData memory);\\n\\n\\n}\\n\",\"keccak256\":\"0xf02fd48efda614a43b09abf069628e12498052cd256ce5ea7fcfc56329ea09a8\",\"license\":\"MIT\"},\"contracts/utils/AddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @notice Key sets with enumeration and delete. Uses mappings for random\\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\\n * fixed gas cost at any scale, O(1).\\n * author: Rob Hitchens\\n */\\n\\nlibrary AddressSet {\\n    struct Set {\\n        mapping(address => uint256) keyPointers;\\n        address[] keyList;\\n    }\\n\\n    /**\\n     * @notice insert a key.\\n     * @dev duplicate keys are not permitted.\\n     * @param self storage pointer to a Set.\\n     * @param key value to insert.\\n     */\\n    function insert(Set storage self, address key) public {\\n        require(\\n            !exists(self, key),\\n            \\\"AddressSet: key already exists in the set.\\\"\\n        );\\n        self.keyList.push(key);\\n        self.keyPointers[key] = self.keyList.length - 1;\\n    }\\n\\n    /**\\n     * @notice remove a key.\\n     * @dev key to remove must exist.\\n     * @param self storage pointer to a Set.\\n     * @param key value to remove.\\n     */\\n    function remove(Set storage self, address key) public {\\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\\n        require(\\n            exists(self, key),\\n            \\\"AddressSet: key does not exist in the set.\\\"\\n        );\\n        if (!exists(self, key)) return;\\n        uint256 last = count(self) - 1;\\n        uint256 rowToReplace = self.keyPointers[key];\\n        if (rowToReplace != last) {\\n            address keyToMove = self.keyList[last];\\n            self.keyPointers[keyToMove] = rowToReplace;\\n            self.keyList[rowToReplace] = keyToMove;\\n        }\\n        delete self.keyPointers[key];\\n        self.keyList.pop();\\n    }\\n\\n    /**\\n     * @notice count the keys.\\n     * @param self storage pointer to a Set.\\n     */\\n    function count(Set storage self) public view returns (uint256) {\\n        return (self.keyList.length);\\n    }\\n\\n    /**\\n     * @notice check if a key is in the Set.\\n     * @param self storage pointer to a Set.\\n     * @param key value to check.\\n     * @return bool true: Set member, false: not a Set member.\\n     */\\n    function exists(Set storage self, address key)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        if (self.keyList.length == 0) return false;\\n        return self.keyList[self.keyPointers[key]] == key;\\n    }\\n\\n    /**\\n     * @notice fetch a key by row (enumerate).\\n     * @param self storage pointer to a Set.\\n     * @param index row to enumerate. Must be < count() - 1.\\n     */\\n    function keyAtIndex(Set storage self, uint256 index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return self.keyList[index];\\n    }\\n}\\n\",\"keccak256\":\"0x3b999937288120e5f0651a80c259e5016f7ed9db37ec78aafb0da8b9d70bcae7\",\"license\":\"MIT\"},\"contracts/utils/UInt256Set.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @notice Key sets with enumeration and delete. Uses mappings for random\\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\\n * fixed gas cost at any scale, O(1).\\n * author: Rob Hitchens\\n */\\n\\nlibrary UInt256Set {\\n    struct Set {\\n        mapping(uint256 => uint256) keyPointers;\\n        uint256[] keyList;\\n    }\\n\\n    /**\\n     * @notice insert a key.\\n     * @dev duplicate keys are not permitted.\\n     * @param self storage pointer to a Set.\\n     * @param key value to insert.\\n     */\\n    function insert(Set storage self, uint256 key) public {\\n        require(\\n            !exists(self, key),\\n            \\\"UInt256Set: key already exists in the set.\\\"\\n        );\\n        self.keyList.push(key);\\n        self.keyPointers[key] = self.keyList.length - 1;\\n    }\\n\\n    /**\\n     * @notice remove a key.\\n     * @dev key to remove must exist.\\n     * @param self storage pointer to a Set.\\n     * @param key value to remove.\\n     */\\n    function remove(Set storage self, uint256 key) public {\\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\\n        // require(\\n        //     exists(self, key),\\n        //     \\\"UInt256Set: key does not exist in the set.\\\"\\n        // );\\n        if (!exists(self, key)) return;\\n        uint256 last = count(self) - 1;\\n        uint256 rowToReplace = self.keyPointers[key];\\n        if (rowToReplace != last) {\\n            uint256 keyToMove = self.keyList[last];\\n            self.keyPointers[keyToMove] = rowToReplace;\\n            self.keyList[rowToReplace] = keyToMove;\\n        }\\n        delete self.keyPointers[key];\\n        delete self.keyList[self.keyList.length - 1];\\n    }\\n\\n    /**\\n     * @notice count the keys.\\n     * @param self storage pointer to a Set.\\n     */\\n    function count(Set storage self) public view returns (uint256) {\\n        return (self.keyList.length);\\n    }\\n\\n    /**\\n     * @notice check if a key is in the Set.\\n     * @param self storage pointer to a Set.\\n     * @param key value to check.\\n     * @return bool true: Set member, false: not a Set member.\\n     */\\n    function exists(Set storage self, uint256 key)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        if (self.keyList.length == 0) return false;\\n        return self.keyList[self.keyPointers[key]] == key;\\n    }\\n\\n    /**\\n     * @notice fetch a key by row (enumerate).\\n     * @param self storage pointer to a Set.\\n     * @param index row to enumerate. Must be < count() - 1.\\n     */\\n    function keyAtIndex(Set storage self, uint256 index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return self.keyList[index];\\n    }\\n}\\n\",\"keccak256\":\"0x31d27b2c71ad5bb53daf91e37e2b56fc89341f0d2015a87efd609e12b93d32c8\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205d5f778ebed2c5bed0d2a0d691ad2572ce4dd88b0744c7d509ac44a6494f299864736f6c63430008060033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205d5f778ebed2c5bed0d2a0d691ad2572ce4dd88b0744c7d509ac44a6494f299864736f6c63430008060033",
  "libraries": {
    "UInt256Set": "0xCc995d7a8c7c499128cB34Ef0dA290F5f4f4EE71",
    "AddressSet": "0xf88EB844922B1ab0e153cF9E9bEefecc9512DE06",
    "MerkleProof": "0xe2f6D7E396B31d50dc5d11aD23c17859aDc95bB3",
    "InterfaceChecker": "0x5ddA1aCa8aF2E4751208877C15730D51Ac965eF5"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}